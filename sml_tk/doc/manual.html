<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<TITLE>sml_tk: Functional Programming for GUIs</TITLE>
	<META NAME="GENERATOR" CONTENT="StarOffice/5.1 (Solaris Sparc)">
	<META NAME="CREATED" CONTENT="20010321;13350800">
	<META NAME="CHANGEDBY" CONTENT="Burkhart Wolff">
	<META NAME="CHANGED" CONTENT="20010323;16101900">
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">

<!-- -----------------------------------------------------------------------
 
   $Source: /repository/sml/sml_tk/doc/manual.html,v $
   sml_tk introduction, documentation and reference manual. 
 
   $Date: 2001/03/30 13:38:00 $
   $Revision: 3.0 $
   Author: bu/cxl/stefan (Last modification by $Author: 2cxl $)
   (C) 1996, Bremen Institute for Safe Systems, Universitaet Bremen
 
    ------------------------------------------------------------------- -->
	<STYLE>
	<!--
		H1 { color: #000000 }
		TD P { color: #000000 }
		H2 { color: #000000 }
		H3 { color: #000000 }
		H4 { color: #000000 }
		P { color: #000000 }
		PRE { color: #000000 }
		DT { color: #000000 }
		DD { color: #000000 }
		A:link { color: #0000ff }
	-->
	</STYLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" BGCOLOR="#ffffff">
<P STYLE="margin-bottom: 0in">&nbsp; 
</P>
<TABLE CELLPADDING=2 CELLSPACING=2>
	<TR>
		<TD>
			<P><A HREF="http://www.uni-bremen.de/"><IMG SRC="images/uni-hb-logo.gif" NAME="Graphic1" ALT="Uni Bremen" ALIGN=BOTTOM WIDTH=268 HEIGHT=49 BORDER=0></A></P>
		</TD>
		<TD>
			<P>&nbsp;</P>
		</TD>
		<TD>
			<P><A HREF="http://www.uni-freiburg.de/"><IMG SRC="images/alu-logo.gif" NAME="Graphic2" ALT="ALU Freiburg" ALIGN=BOTTOM WIDTH=223 HEIGHT=80 BORDER=0></A></P>
		</TD>
	</TR>
	<TR>
		<TD>
			<P><A HREF="http://www.informatik.uni-bremen.de/">FB3- Mathematics
			and Computer Science</A></P>
		</TD>
		<TD></TD>
		<TD>
			<P><A HREF="http://www.informatik.uni-freiburg.de/">Institut f&uuml;r
			Informatik</A></P>
		</TD>
	</TR>
</TABLE>
<HR>
<H1><B>sml_tk</B>: Functional Programming for Graphical User
Interfaces</H1>
<H3>Release 3.0</H3>
<P STYLE="margin-bottom: 0in"><A HREF="http://www.informatik.uni-bremen.de/~cxl/">Christoph
L&uuml;th</A> and <A HREF="http://www.informatik.uni-freiburg.de/~wolff/">Burkhart
Wolff</A> 
</P>
<HR>
<H2>Contents:</H2>
<H3><A HREF="#intro"><B>1. A Gentle Introduction to sml_tk</B></A></H3>
<H3><A HREF="#design_issues">2. Design Issues</A></H3>
<H3><A HREF="#ref_man">3. The <B><U><FONT COLOR="#0000ff">sml_tk</FONT></U></B>
Reference Manual</A></H3>
<H3><A HREF="#toolkit">4. The sml_tk Toolkit</A></H3>
<H3><A HREF="#installation">5. Installation</A></H3>
<H3><A HREF="#bib">6. Bibliography</A></H3>
<H3><A HREF="#appx">7. Appendix: A Commented Logfile</A></H3>
<HR>
<H2><A NAME="intro"></A>1. A Gentle Introduction to sml_tk</H2>
<H3>What is <B>sml_tk</B>?</H3> <P><B>sml_tk</B> is a Standard ML
(SML) package that provides a portable, typed and abstract interface
to the user interface description and command language
Tcl/Tk. <B>sml_tk</B> was originally developed in the <A
HREF="http://www.informatik.uni-bremen.de/uniform">UniForM-Project</A>
and has been continually developed since by the universities of Bremen and
Freiburg.</P> 
<P>Tcl/Tk consists of two components, which in principle are
independent: the interface toolkit Tk offering a highly portable
interface to various operating systems and their graphical display engine
(such as Windows, MacOS and UNIX with its X Window System)  and
the command language Tcl, a weakly typed Lisp-like scripting
language. (For more information, see [Oust94], [REF 96], [HM 97], [Fos 97],
[Wel 97] or
the <A HREF="http://dev.scriptics.com/software/tcltk/">home page</A>). While we appreciate both Tk's portability and level of
abstraction to access a window system, we do not subscribe to the Tcl
design philosophy that one should have a weakly typed and structured
scripting language to tie together smallish applications written in
another language. We believe that this leads to all the kind of
drawbacks one wants to avoid by using a structured language in the
first place (code that is ugly to read, prone to errors and hard to
maintain), and that one should use a structured language which offers
structuring concepts in-the-large for this purpose, such as Standard
ML [Pau94] with its module language. Hence, we prefer to use Tk to
build graphical user interfaces for applications written in the
functional language SML via an interface from SML directly.
</P>
<P>The package <B>sml_tk</B> has been designed to combine the
advantages of the Tk toolkit with those of SML. As a consequence, a
novice in interface programming can skip the first fifteen chapters
of the reference book [Oust94] dealing with Tcl and concentrate on
those parts of the book addressing the visual appearance of graphical
objects and their layout control using Tk. <B>sml_tk</B> covers most of the Tk functionality, and
is easy to extend. 
</P>
<P>Part of the <B>sml_tk</B> package is a toolkit library of reusable
interface building components, including 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">a collection of frequently used
	windows to display error messages, warnings or prompt for user
	input, 
	</P>
	<LI><P STYLE="margin-bottom: 0in">a file browser (&quot;sml_tk
	Explorer&quot;), 
	</P>
	<LI><P STYLE="margin-bottom: 0in">a generic drag&amp;drop-canvas, 
	</P>
	<LI><P STYLE="margin-bottom: 0in">a generic tree-navigation-canvas,
	and 
	</P>
	<LI><P>a generic user interface GenGUI. 
	</P>
</UL>
<P>This library highly profits from the SML module system. For
example, <tt>GenGUI</tt> is a functor which when instantiated with an
application yields a graphical user interface controlling that
application. We have used this toolkit library to implement user
interfaces for applications based on theorem provers (see [LW99] and
[LW00]). 
</P>
<P>The core of <B>sml_tk</B> implements the following entities: 
</P>
<UL>
	<li><P><I>Windows</I> (the basic building block of a graphical user
	interface) 
	</P>
	<li><P STYLE="margin-bottom: 0in"><I>Widgets </I>(graphical objects with
	a particular appearance and behaviour like Buttons, Menus or
	Textfields); 
	</P>
	<li><P STYLE="margin-bottom: 0in"><I>Annotations</I> (of a text, like
	hyperlinks, inserted pictures or buttons); and 
	</P>
	<li><P><I>Canvas Items</I> (items on a drawing area, a so-called canvas,
	such as lines, points, small icons, text). 
	</P>
</UL>
<P>Each of these corresponds to an SML datatype, called <TT>Window</TT>,
<TT>Widget, Annotation </TT>and <TT>CItem </TT>respectively. Any of
these objects must have a unique <I>identification</I> (&quot;id&quot;)
that is used to reference them. The management of these
identifications and their mapping to appropriate names in Tcl is
handled by <B>sml_tk</B>. The central datatype <TT>Widget</TT> provides
one variant for each graphical entity like buttons, labels, menus,
text fields, etc. They are usually composed of the following: 
</P>
<UL>
	<LI>an identifier (<I>widget id</I>) 
	<LI>a list of subwidgets, if
	applicable (e.g. a menu
	consists of buttons); 
	<LI><I>bindings,&nbsp;</I>which
	specify which SML functions are activated by <I>events</I> (such as
	mouse clicks, see below) in the GUI. These functions, called
	&quot;actions&quot; control the application in an event-triggered way 
	<LI><I>configurations</I>,
	(&quot;resources&quot; in the sense of [Oust94]) determining the
	visual appearance of the widget; 
	<LI><I>Packing options</I> specifying the 
	placement of widgets, either in a fairly declarative style relative
	to each other (e.g. X should be left from Y, and both should be
	placed on top of Z) , or in a grid-oriented style (e.g. this widget
	goes in the third column of the second row). 
</UL>
<P><I>Windows</I> are essentially given by 
</P>
<UL>
	<LI>an <I>identifier</I> (window id), 
	<LI><I>window configurations</I>, such
	as the title and geometry, 
	<LI>the list of widgets occuring in
	that window 
	<LI>and a list of bindings. 
</UL>
<P>Such a window, described by an ML expression, can either be passed
to the function <TT>startTcl</TT> that creates a GUI (consisting of
this window or possibly a list of windows) as a reactive system, or
to suitable operations that create windows dynamically during the
lifetime of the reactive system. While the reactive system is
running, the input from the SML interpreter is blocked, so the
function <TT>startTcl</TT> only returns once the reactive system has
terminated (i.e. the main window has been closed again). 
</P>
<H3>A Small Example</H3>
<P>To give a flavour of programming in <B>sml_tk</B>, we sketch a
small example: suppose we want to construct a small window consisting
of a text entry field labelled &quot;name:&quot; left from this
field, and a quit button. After clicking on the text field, new text
can be entered and line-edited. After finishing by hitting the Return
key, the entered text should rename the window. When the quit button
is pressed (i.e. clicked on with the mouse) the window should be
closed, and the example terminates. 
</P>
<P>After opening the structures <TT>TkTypes</TT> and <TT>SmlTk</TT>,
which contain the export signature of <B>sml_tk</B> as described in
detail below, we are ready to start. We will have three graphical
entities (widgets): 
</P>
<UL>
	<LI>the text entry field,
	<LI>the text label &quot;name:&quot;,
	<LI>and the quit button.
</UL>
<P>All of these are of the type <TT>widget</TT>, using the three
constructors <TT>Entry</TT>, <TT>Label</TT> and <TT>Button</TT>. We
first need two identifiers, one for the main window and one for the
text entry widget, which we generate by the two functions <TT>newWinId</TT>
and <TT>newWidgetId</TT>, respectively: 
</P>
<PRE>val mainID = newWinId()
val entID = newWidgetId()</PRE><P>
The other two widgets can remain anonymous, since we need not refer
to them explicitly. 
</P>
<PRE>(* Define the widgets: *)

val lab = Label{widId=newWidgetId(), packings=[Side Left]
                configs=[Text &quot;name:&quot;], bindings=[]}
val input = let fun endInput _ = changeTitle mainID (mkTitle(readTextAll entID))
            in Entry{widId=entID, packings=[], configs=[Width 20],
                     bindings=[BindEv(KeyPress &quot;Return&quot;,endInput)]}
            end
val quit = let fun stop _ = closeWindow mainID
           in Button{widId=newWidgetId(), packings=[Side Bottom],
                     configs=[Text &quot;Quit&quot;, Command stop],
                     bindings=[]}
           end</PRE><P>
The action <TT>endInput</TT> is bound to the the <I>Return</I> key,
and the button labelled <TT>Quit</TT> is configured such that the
action <TT>stop</TT>, which closes the main window and hence
terminates the application, is executed when the button is pressed. 
</P>
<P>The layout is achieved as follows: the two widgets <TT>label</TT>
and <TT>input</TT> should be placed side by side on top, with the
widget <TT>quit</TT> at the bottom. To put two widgets side by side,
we put them in one widget called a frame: 
</P>
<PRE>val topblock = Frame{widId=newWidgetId(), widgets=Pack [lab, input],
                          packings=[Side Top], configs=[], bindings=[]}</PRE><P>
We are now ready to create the main window: 
</P>
<PRE>
val enterwin = {winId = mainID,
                config = [WinTitle &quot;Please enter name&quot;],
                widgets = Pack [topblock, quit],
                bindings = [],
                init = noAction}</PRE><P>
Note that the order of the widgets is not important in this
particular example. However, in general order here is relevant.
Moreover, the result of the Tk layout and packing algorithm can be
somewhat surprising, and may require some experimentation. 
</P>
<P>We now have to initialize <B>sml_tk</B>; this has to be done
before any <B>sml_tk</B> application is started. After that, we can
start our small GUI: 
</P>
<PRE>SmlTk.init();
startTcl [mkWindow enterwin];</PRE><P>
The following window appears on the screen: 
</P>
<P><IMG SRC="images/small_ex.1.gif" NAME="Grafik3" ALT="[Imagine asmall window here.]" ALIGN=BOTTOM WIDTH=150 HEIGHT=80 BORDER=0>
</P>
<P>We can now click on the entry field, and type in some text,
finishing with &lt;Return&gt;, and we get: 
</P>
<P><IMG SRC="images/small_ex.2.gif" NAME="Grafik4" ALT="[Imagine asmall window here with its title changed to qwerty]" ALIGN=BOTTOM WIDTH=150 HEIGHT=80 BORDER=0>
</P>
<P>&quot;Pressing&quot; the quit button (i.e. moving the cursor over
it and pressing a mouse button) closes the window and terminates the
<TT>startTcl</TT> command. 
</P>
<H3>About this document</H3>
<P>The purpose of this documentation is: 
</P>
<UL>
	<LI>to give an informal description of the design of <B>sml_tk</B>
	for users familiar with SML
	<BR>but unacquainted with Tk or graphical interface programming
	in general, 
	</li>
	<li>to explain the design rationale behind <B>sml_tk</B> (Section 2), </li>
	<li>to serve as a reference manual to
	<B>sml_tk</B> and its components (Section 3), 
	</li>
	<li>to give a description of the toolkit library (Section 4), and</li>
	<li>to explain how to install <b>sml_tk</b> (Section 5)</li>
</UL>
A detailed description of small examples and some tricks and
debugging techniques may help beginning programmers. We suggest using
some of the smaller examples and extending them stepwise - many
frustrating beginner's errors are avoided this way. The example above
can be found in the directory <TT>src/tests+examples</TT> in the file
<TT>small_ex.sml</TT>; that directory also contains many more
examples that the beginning <B>sml_tk</B> programmer is encouraged to
have a look at. 
</P>
<P>This document is not intended to replace a <A HREF="http://www.tclconsortium.org/resources/manpages/">Tk-Reference
Manual</A>, rather to be complementary. For serious working with
<B>sml_tk&nbsp;</B><SPAN STYLE="font-weight: medium">the user will
constantly want to consult this document in order to get more
information on legal options or the visual appearance of widgets.</SPAN>
</P>
<H3>History and Acknowledgements</H3>
<P>A first version of <B>sml_tk</B> [KSW96] was developed from
GoferTK [VTS95]. After translating it from a lazy pure functional
language (Gofer) into an eager impure functional language (SML), and
the extension of the functionality in the following versions, only a
passing similarity remains, but we acknowledge the ancestry. We also
snatched some code for the <I>TCL_INSIDE</I> configuration on the
C-level. 
</P>
<P>More recently, Elsa Gunter and Dave McQueen of Bell Labs have made
many suggestions and contributions which we gratefully acknowledge;
in particular, Elsa Gunter has provided the implementation for
polygons, arrowheads, and mixed colours.

<P> For the current release, Erik Behrends provided code for the
<i>TCL_INSIDE</i> configuration, and Andre L&uuml;dtke many invaluable
improvements on both the kernel and the toolkit (in particular, the filer).
</P>

<H2><A NAME="design_issues"></A>2. Design Issues</H2>
<P>Technically, <B>sml_tk</B> starts a Tcl interpreter (called a <I>wish</I>
for <U>wi</U>ndowing <U>sh</U>ell) either as subprocess or a
subroutine. During runtime, <B>sml_tk</B> compiles
the description of the user interface (given by Widgets, Windows, etc
described above) into Tcl expressions which are passed to the wish.
<BR><B>sml_tk</B> comes in two configurations: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">the default configuration is based
	on a loose coupling with the <I>wish</I>, which is created
	as a child process. The connection between the
	wish and <B>sml_tk</B> is established via pipes, which is
	sufficiently fast for most applications and machines. This
	configuration runs with all SML compilers implementing the <TT>Posix</TT>
	module, on operating systems such as Linux and
	Solaris, but not Windows. 
	</P>
	<LI><P>In the so-called <I>TCL_INSIDE</I> configuration Tk is linked
	into the SML runtime system. This configuration is only available
	for one particular implementation of SML, namely SML of New Jersey
	(SML/NJ). It offers higher speed, but is slightly more difficult to
	install. However, <I>TCL_INSIDE</I> is independent from the <TT>Posix</TT>
	module of SML (and thus potentially easier to port to Windows). 
	</P>
</UL>
<P><B>sml_tk</B> keeps an internal GUI state consisting of a list of
windows and additional information. This state is a logical image of
the (external) state of the wish. This is pretty much in the style of
[VTS95], but in contrast to the Tk interface caml_tk [PR95], where
widgets and windows are built by successive calls of functions with
side effects; in <B>sml_tk</B>, the data types for widgets and
windows are <I>freely generated</I> in order to support a more
functional style of programming, with less side effects. 
</P>
<P>The functionality of <B>sml_tk</B> can be divided into the
following categories: 
</P>
<OL>
	<li>constructors and selectors (<TT>selXX</TT>)
	for all datatypes;</li>
	<li>functions for dynamically <I>adding</I>,
	<I>deleting</I> and <I>updating</I> (exchanging) widgets, widget
	components or windows to the GUI;</li>
	<li>functions to inspect components in the
	GUI state (<TT>getXX</TT>)</li>
	<li>functions to inspect the actual state of the wish (<TT>readXX</TT>);</li>
	<li>functions to set the actual state of the wish (<TT>setXX</TT>,
	<TT>insertXX</TT>)</li>
</OL>
<P>The user can change the state of the wish by inserting text into a
text widget, by clicking on a radio button, by selecting a text in a
listbox, by inserting a cursor into a text, by manipulating a
scrollbar or by resizing a window. Since it would require far too
much implementation overhead to enforce the equivalence between GUI
state and state of the wish <I>automatically </I>and at all times,
the distinction between the <TT>getXX</TT>-functions and the
<TT>readXX</TT>-functions is crucial. In many cases, configuration
and coordinates in the GUI state represent only the <I>initial</I>
value, while the actual values have to be explicitly read from the
wish. This is especially the case for Tcl variables, cursor positions
within a texts, and texts editable by the user. 
</P>
<P>The GUI state is particularly useful to realize a binding
mechanism. To most widgets, bindings can be annotated with the
constructor <TT>BindEv</TT>, which takes as arguments an <I>event</I>
and an <I>action</I>. An event is given by the structured data type
<TT>Event</TT>, which models events as given in Tcl (see [Oust94],
Chapter 8, pp. 199) in a structured way (examples are the events
<TT>ButtonPress(SOME 1)</TT> for the first mouse button being
pressed, or <TT>KeyPress &quot;Return&quot;</TT> for the Return key
being pressed), and an <I>action</I>, which is an ML function of the
functionality <TT>TkEvent-&gt; unit</TT>. <TT>TkEvent</TT> is a data
type containing information on the cursor position (both relative to
the window and absolute and the buttons pressed) etc. <B>sml_tk</B>
will map the ML functions (actions) to the events as extracted from
the GUI state, and call the relevant ML function when the specified
event occurs. 
</P>
<P>Tk is not completely orthogonal. In some cases, configuration
options for a widget are expressed differently for each individual
widget; <B>sml_tk</B> allows to abstract from these.  However, the
problem remains that not every component can be arbitrarily combined
with each other, e.g. only particular widgets are allowed to build a
menu. In Tk these constraints are checked dynamically.  Since SML does
not contain a subclass concept like <A
HREF="http://www.haskell.org/">Haskell</A> which would allow to
express such contextual side conditions on the type level, a
compromise had to be made between precision in modelling the data
types on the one hand and usability, flexibility and simplicity of the
<B>sml_tk</B> user interface on the other. This compromise consists in
collecting all configuration options into one data type, leaving
violations to dynamic checks, while in all other places the
construction of widgets is as accurate as possible.
</P>
<P>Since Tcl does not provide any data type other than texts, and in
particular no constructors for aggregations like arrays or lists,
some ad-hoc constructs had been introduced to express collections and
groups of objects. Since SML offers better ways to represent
aggregations, <B>sml_tk</B> does not support these concepts and hence
sometimes simplifies the view of Tk. This holds also for scrollbars
(on text widgets and canvas widgets) which are no longer widgets in
their own right in <B>sml_tk</B>. 
</P>
<P>An important design decision was made in binding SML functions
(rather than threads) to events. This is the basis for <B>sml_tk</B>'s
simplicity; available concurrency toolkits (such as John Reppy's
Concurrent ML, which unfortunately is based on cooperative
multitasking) would limit <B>sml_tk </B>to particular SML
implementations without providing a full solution to important
requirements (such as a kill-button for diverging threads). For these
reasons we stuck to the binding of functions to events (giving the
control to the application during its evaluation) and provided an
ad-hoc solution for the kill-button (see <A HREF="#extensions">below</A>).
</P>
<H2><A NAME="ref_man"></A>3. The <B>sml_tk</B> Reference Manual</H2>
<P>This chapter contains a technical description of <B>sml_tk</B>'s
export interface in a reference manual style. The export interface
consists of two signatures: 
</P>
<UL>
	<li><I><tt>TK_TYPES</tT></I>
	(in the file <TT>sml_tk/src/tk_types.sml</TT>), contains the types,
	data types along with their constructors and selectors, and
	exceptions provided by <B>sml_tk</B>. This will be described in
	section 3.1.</li>
	<li><TT><I>SML_TK</I></TT> (in the file <TT>sml_tk/src/export.sml</TT>)
	contains the functions provided by <B>sml_tk</B>, as described in
	section 3.2.</li>
</UL>
<P>The two signatures correspond to the way in which an <B>sml_tk</B>
application's interface is build: firstly, using the data types from
<TT><I><FONT FACE="courier">TK_TYPES</FONT></I></TT>, the initial
appearance of the interface is specified in a declarative way. Then
control is passed to <B>sml_tk</B>, and the runtime behaviour of the
application is a <I>reactive system</I>, i.e. the application's
behaviour is a reaction to the user's input, implemented using the
functions from <TT><I>SML_TK</I></TT> which allow dynamic changes to
the interface and much more. 
</P>
<P>The main structure of <B>sml_tk</B> is the structure <TT>SmlTk</TT>.
Its export interface consists of a join of the two signatures
<TT>TK_TYPES</TT> and <TT>SML_TK</TT>, which completely restrict the
implementing structure (also in the file <TT>sml_tk/src/export.sml</TT>).
In SML terminology, the joint signature is the <I>opaque&nbsp;</I> interface
to <B>sml_tk</B>. 
</P>
<H3>3.1. The Signature <TT>TK_TYPES</TT></H3>
<P>This section describes the signature <TT>TK_TYPES</TT>. It mainly
contains the data types, constructors and selectors for <I>freely
generated term structure</I> by which the user interface can be
specified in a declarative way. 
</P>
<P>The data structures closely mirror the Tk concepts. In order to
understand these concepts, such as the different kinds of widgets,
their purpose and configuration options, the graphical layout and the
behaviour of the Tk layout algorithm (the &quot;packer&quot;), it
will be necessary to consult the Tcl/Tk-book [REF 96] or the <A HREF="http://www.tclconsortium.org/resources/manpages/">manual
pages</A> from the Tcl/Tk distribution package. This documentation
will not try to explain these Tk concepts, but rather point out where
<B>sml_tk</B> behaves differently from Tk. 
</P>
<H4>3.1.1 Identifiers</H4>
<P>The following types are identifiers for windows, widgets, canvas
items, text annotations and images, respectively. See <A HREF="#ids">section
3.2.1</A> below how to create identifiers. 
</P>
<PRE> type WinId
 type WidId
 type CItemId
 type AnnId
 type ImageId</PRE><H4>
<A NAME="exceptions"></A>3.1.2. Exceptions</H4>
<P>Exceptions usually indicate a programming error. Favourite
examples include referring to non-existing widgets, windows or canvas
items, wrong configurations (some widgets require certain
configurations whereas others prohibit them), applying partial
selectors to the wrong variant of the data type, using non-existing
fonts or loading non-existing images. 
</P>
<PRE> exception CITEM of string
 exception WIDGET of string
 exception TCL_ERROR of string
 exception CONFIG of string
 exception WINDOWS of string</PRE><P>
There are two functions by which to start an <B>sml_tk</B>
application; one catches these exceptions and prints the relevant
string (containing an error message), and one does not (see <A HREF="#eventloop">section
3.2.2</A> below). It should be pointed out these exceptions indicate
some kind of malfunction, usually a programming error, so just
catching them and continuing is not such a bright idea. 
</P>
<H4>3.1.3. <TT>TkEvents</TT>, Actions and Bindings</H4>
<P>When running as reactive system, activation is driven by <I>events</I>
such as mouse buttons or keys being pressed, or widgets (to be exact,
their graphical representation on the screen) being entered or left
with the cursor. 
</P>
<P>The most common reaction in Tk applications is that of a <TT>Command</TT>.
Commands are specified as part of the <I>Configure</I> information in
widgets such as buttons. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> type SimpleAction = (unit -&gt; unit)</PRE><P>
For finer control of the interactive behaviour of the application,
the data type <TT>Binding</TT> specifies a particular event and the
corresponding reaction. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> datatype Binding = BindEv of Event * Action</PRE><P>
Events are given by the datatype <TT>Event</TT>. Events are either
basic events, or modifications of events. Basic events are: 
</P>
<UL>
	<li>keys being pressed or released (<TT>KeyPress</TT>, <TT>KeyRelease</TT>;
	the argument is a string describing the key being pressed, e.g. <TT>&quot;a&quot;</TT>
	or <TT>&quot;Return&quot;</TT>&quot;), 
	</li>
	<li>mouse buttons being pressed or
	released (<TT>ButtonPress</TT>, <TT>ButtonRelease</TT>; the
	<BR>argument here is a specific mouse button, or <TT>NONE</TT> for
	any mouse button), or 
	</li>
	<li>the cursor entering (<TT>Enter</TT>), leaving (<TT>Leave</TT>),
	or moving (<TT>Motion</TT>) within a window or widget.</li>
</UL>
<P>These can be modified as follows: 
</P>
<UL>
	<li>A modifier key being pressed while the
	event occurs. Modifier keys are <TT>Shift</TT>, <TT>Ctrl</TT>, <TT>Lock</TT>,
	<TT>Any</TT>, <TT>Alt</TT>,<TT>Meta</TT>, <TT>Mod3</TT>, <TT>Mod4</TT>
	or <TT>Mod5</TT> (your keyboard may not provide all of these,
	though).</li>
	<li>A <TT>ButtonPress</TT> event occurs
	twice or thrice within a certain period of time (<TT>Double</TT> or
	<TT>Triple</TT>).</li>
	<li>A mouse button is being pressed while the event occurs
	(<TT>ModButton</TT>).</li>
</UL>
<P>A final different kind of event is given by <TT>UserEv</TT>, which
takes as argument a description of events in the style of Tcl (see
[Oust94] section 18.3). This kind of event description is strongly
discouraged, though, since syntactically wrong event descriptions
lead to a wish runtime error. 
</P>
<PRE> datatype Event =
 (* window events *)
 FocusIn
 | FocusOut
 | Configure
 | Map
 | Unmap
 | Visibility
 | Destroy
 (* Key press/release events *)
 | KeyPress of string
 | KeyRelease of string
 (* Button press/release events, NONE means any old Button *)
 | ButtonPress of int Option.option
 | ButtonRelease of int Option.option
 (* Cursor events *)
 | Enter | Leave | Motion
 (* user-defined events, or explicitly given events *)
 | UserEv of string
 (* event modifiers *)
 | Shift of Event | Ctrl of Event | Lock of Event | Any of Event
 | Double of Event | Triple of Event
 | ModButton of int* Event
 | Alt of Event | Meta of Event
 | Mod3 of Event | Mod4 of Event | Mod5 of Event</PRE><P STYLE="line-height: 100%">
Not all possible combinations make sense though; for example, a
button event modified with a different button, or a doubled enter
event are clearly paradoxical (and hence will never occur, so binding
anything to them is a lost cause). An <TT>Action</TT> is an ML
function to be called when the specified event occurs:</P>
<PRE STYLE="margin-bottom: 0.2in"> type Action = (TkEvent -&gt; unit)</PRE><P>
Events have the following structure: 
</P>
<PRE> 
datatype TkEvent =
 TkEvent of int (* %b button number *)
          * string (* %s state field *)
          * int (* %x x field *)
          * int (* %y y field *)
          * int (* %X x_root field *)
          * int (* %Y y_root field *)</PRE><P>
The corresponding selector functions are: 
</P>
<PRE> 
 val selButton   : TkEvent -&gt; int
 val selState    : TkEvent -&gt; string
 val selXPos     : TkEvent -&gt; int
 val selXRootPos : TkEvent -&gt; int
 val selYPos     : TkEvent -&gt; int
 val selYRootPos : TkEvent -&gt; int</PRE><P>
When no binding for an event has been specified, nothing happens,
e.g. a button press in a canvas widget is simply ignored if no
binding has been specified and does <I>not</I> lead to an error. 
</P>
<P>With some widgets or items, not all events are allowed in their
binding; further, the information in <TT>TkEvent</TT> is only valid
for some, but not all of the events. See chapter 18 in the Tcl/Tk
handbook [Oust94] or the <TT>bind</TT> manual page about the details
of events and bindings. 
</P>
<P>Be also warned that the interaction between mouse button presses
and mouse movements is fairly intricate: when a mouse button is being
pressed, all subsequent mouse events go to the widget or item over
which this event has occurred until the mouse button is released. In
particular, no enter event is generated if the mouse is moved into
another widget, item or window with the mouse button pressed, the
enter event will only be generated once the mouse button has been
released. 
</P>
<P>Finally, be aware that the <I>keyboard focus</I> (see <A HREF="#focus">section
3.2.14</A>) determines where keyboard events go. It will rarely make
sense to bind actions to keys in widgets other than text widgets or
entry widgets, since these other widgets will usually not be in a
position to receive keyboard events. 
</P>
<H4>3.1.4. Fonts</H4>
<P>Fonts in <B>sml_tk</B> are described by the data type <TT>Font</TT>,
which offers a slight abstraction over the standard X11 description.
The idea is to provide a set of standard fonts, which can be modified
for style and size. These standard fonts are mapped (on calling
<TT>SmlTk.init</TT>) to specific X11 fonts. If a specific font is not
found (e.g. in a particular size or weight), another one is selected.
This approach has been chosen because fonts are provided by the X
server, and hence can change; this way, applications can still use
different fonts, but are not dependent on any particular X11 font
being present in the server. 
</P>
<P>The standard fonts are <TT>Normalfont</TT>, <TT>Typewriter</TT>,
<TT>SansSerif</TT> and <TT>Symbol</TT>. They can be modified as <TT>Bold</TT>,
<TT>Italic</TT>, <TT>Tiny</TT> (very small), <TT>Small</TT>,
<TT>NormalSize</TT>, <TT>Large</TT> and <TT>Huge</TT>. The modifier
<TT>Scale</TT> allows to scale fonts arbitrarily, where <TT>Scale 1.0</TT>
has the same effect as <TT>NormalSize</TT>. Users insisting on a
particular X11 font can obtain these by <TT>XFont</TT>. 
</P>
<PRE> datatype FontConfig = Bold | Italic |
                       Tiny | Small | NormalSize | Large | Huge |
                       Scale of real

 datatype Font = XFont of string
               | Normalfont of FontConfig list
               | Typewriter of FontConfig list
               | SansSerif of FontConfig list
               | Symbol of FontConfig list</PRE><P>
The mapping of the standard fonts to the X11 font implementing them
is described by the type <TT>Fonts.Config</TT>. The provided defaults
are as follows: 
</P>
<PRE> 
val Config = {Normalfont = ref &quot;-*-courier&quot;,
              Typewriter = ref &quot;-misc-fixed&quot;,
              SansSerif = ref &quot;-*-helvetica&quot;,
              Symbol = ref &quot;-*-symbol&quot;,
              BaseSize = ref 12,
              ExactMatch = ref true,
              Resolution = ref 75
             }</PRE><H4>
3.1.5. Widget Configuration Options</H4>
<P><TT>Configure</TT> information correspond to Tk's <I>options</I>.
It is the information used to customise the predefined widgets.
Configure options which have not been specified are left open, and
the default for the widget type in question is chosen. 
</P>
<P>The effects and intended use of the various configuration options,
and which option is valid for which kind of widget, can be found in
the Tk manual. The following configure options are supported by
<B>sml_tk</B>. For every constructor we give the corresponding Tk
option for easier reference to the Tk manual pages. 
</P>
<PRE> datatype Configure =
 Width of int (* -width ... *)
 | Height of int (* -height ... *)
 | Borderwidth of int (* -borderwidth ... *)
 | Relief of RelKind (* -relief ... *)
 | Foreground of Color (* -foreground ... *)
 | Background of Color (* -background ... *)
 | MUnderline of int (* -underline ... for menus *)
 | Accelerator of string (* -accelerator &quot;bla&quot; *)
 | Text of string (* -Label &quot;bla&quot; *)
 | Font of Fonts.Font (* -font &quot;bla&quot; *)
 | Variable of string (* -variable &quot;bla&quot; *)
 | Value of string (* -value &quot;bla&quot; *)
 | Icon of IconKind (* -bitmap or -image ... *)
 | Cursor of CursorKind (* -cursor ... *)
 | Command of SimpleAction (* -command ... *)
 | Anchor of AnchorKind (* -anchor ... *)
 | FillColor of Color (* -fill ... *)
 | Outline of Color (* -outline ... *)
 | OutlineWidth of int (* -width ... *)
 | Smooth of bool (* -smooth .. *)
 | Arrow of ArrowPos (* -arrow ... *)
 | ScrollRegion of int * int * int * int (* -scrollregion ... *)
 | Capstyle of CapstyleKind (* -capstyle ... *)
 | Joinstyle of JoinstyleKind (* -joinstyle ... *)
 | ColorMap of ColorMapEntry list (* -colormap ... *)
 | ColorMode of colorMode (* -colormode ... *)
 | File of string (* -file ... *)
 | FontMap of FontMapEntry list (* -fontmap ... *)
 | PrintHeight of string (* -height ... *)
 | PageAnchor of AnchorKind (* -pageanchor ... *)
 | PageHeight of string (* -pageheight ... *)
 | PageWidth of string (* -pagewidth ... *)
 | PageX of string (* -pagex ... *)
 | PageY of string (* -pagey ... *)
 | Rotate of bool (* -rotate ... *)
 | PrintWidth of string (* -width ... *)
 | PrintX of string (* -x ... *)
 | PrintY of string (* -y ... *)
 | Offset of int (* -offset ... Offset over baseline for texts *)
 | Underline (* -underline ... underline for texts (see MUnderline above) *)
 | Justify of Justify (* -justify ... Justification: left/right/center *)
 | Wrap of WrapMode (* -wrap ... *)
 | Orient of Orientation (* -orient ... *)
 | Active of bool (* -state ... *)

 (* Scale configurations *)
 | SLabel of string (* -label ... *)
 | Length of int (* -length ... *)
 | SliderLength of int (* -sliderlength ... *)
 | From of real (* -from ... *)
 | To of real (* -to ... *)
 | Resolution of real (* -resolution ... *)
 | Digits of int (* -digits ... *)
 | BigIncrement of real (* -bigincrement ... *)
 | TickInterval of real (* -tickinterval ... *)
 | ShowValue of bool (* -showvalue ... *)
 | SliderRelief of RelKind (* -sliderrelief ... *)
 | SCommand of ScaleAction (* -command ... special command for use with scales (called with the scale value) *)
 | RepeatDelay of int (* -repeatdelay ... *)
 | RepeatInterval of int (* -repeatinterval ... *)
 | ThroughColor of Color (* -throughcolor ... *)

 | InnerPadX of int (* -padx ... *)
 | InnerPadY of int (* -pady ... *)
 | Show of char (* -show ... (password entry fields etc.) *)
 | Tearoff of bool (* -tearoff ... tearoff for menus *)</PRE><H4>
Relief</H4>
<PRE> datatype RelKind = Flat | Groove | Raised | Ridge | Sunken</PRE><P>
The relief customises the visual three-dimensional appearance (see
[Oust94] section 16.1.1) of widgets. 
</P>
<H4>Colours</H4>
<PRE> 
datatype Color = NoColor | Black | White | Grey | Blue | Green | Red | Brown | Yellow
               | Purple | Orange | Mix of {red : int, blue : int, green : int}</PRE><P>
We apologise to British users for the spelling (and blame Tk for it).
</P>
<H4>Anchor Kind</H4>
<PRE> datatype AnchorKind = North | NorthEast |
                       East | SouthEast |
                       South | SouthWest |
                       West | NorthWest |
                       Center</PRE><P>
<A NAME="icons1"></A>The option <TT>AnchorKind</TT> is used for the
orientation of an object with respect to their position (anchor) (see
[Oust94] section 16.11.2). 
</P>
<H4>Capstyle and Joinstyle</H4>
<P>These datatypes describe how lines, when drawing on a canvas, are
joint. 
</P>
<PRE> datatype CapstyleKind = Butt | Projecting | Round
 datatype JoinstyleKind = Bevel | Miter | RoundJoin</PRE><H4>
Icons and Images</H4>
<PRE> type BitmapName
 type BitmapFile
 type ImageFile

 datatype IconKind =
 NoIcon
 | TkBitmap of BitmapName (* -bitmap &lt;tk bitmap&gt; *)
 | FileBitmap of BitmapFile (* -bitmap @&lt;filename&gt; *)
 | FileImage of ImageFile * ImageId (* -image ... *)</PRE><P>
<TT>TkBitmap</TT> and <TT>FileBitmap</TT> allow the usage of X11
bitmaps. <TT>BitmapName</TT> must be the name of one of Tk's internal
bitmaps. <TT>BitmapFile</TT> specifies a pathname of a file with the
appropriate format. Bitmaps can be used with some widgets such as
<TT>Label</TT> or <TT>Button</TT> (see also the <TT>bitmap</TT>
manual page or [Oust94] section 16.3.3), and in <I>canvas items</I>
(see <A HREF="#citems">section 3.1.7</A>). 
</P>
<P>Tk also supports images (with depth more than 1). Images are
specified with <TT>FileImage</TT>, where <TT>ImageFile</TT> is the
pathname of a file in a recognised format such as GIF (for other
formats supported see the <TT>image</TT> manual page). Examples can
be found in <TT>src/tests+examples/big_ex.sml</TT>. 
</P>
<P>The three types <TT>BitmapName</TT>, <TT>BitmapFile</TT> and
<TT>ImageFile</TT> are synonymous with <TT>string</TT>. 
</P>
<H4>Cursors</H4>
<PRE> type CursorName
 type CursorFile

 datatype CursorKind =
 NoCursor
 | XCursor of CursorName * ((Color * (Color option )) option )
 | FileCursor of CursorFile * Color * ((CursorFile * Color) option )</PRE><P>
With <TT>XCursor</TT> the predefined Tk cursors can be used, where
the argument <TT>CursorName</TT> is the name of a Tk cursor. The next
two optional arguments are for the foreground and background colour
of the bitmap cursor. 
</P>
<P>One can also use self-designed cursors via the constructor
<TT>FileCursor</TT>. The first argument is the name of the bitmap
file (<TT>CursorFile</TT>) for the cursor, the second the foreground
colour and the last two optional arguments are a mask file
(<TT>CursorFile</TT>) and the respective background colour. 
</P>
<P>The types <TT>CursorName</TT> and <TT>CursorFile</TT> are
synonymous with <TT>string</TT>. 
</P>
<P>Examples can be found in <TT>src/tests+examples/big_ex.sml</TT>
and details in [Oust94] section 16.11.1. 
</P>
<P>If users find they need to use Tk options which are not supported
by <strong>sml_tk</strong>, they are invited to add support for them;
look at <TT>src/config.sml</TT> to see how the other configurations
are translated in Tcl code (and that is essentially all there is to
do).
</P>
<H4>3.1.6. Controlling the Layout</H4>
<P>The layout in <B>sml_tk</B> is done with the Tk packer. Since
release 3.0 <B>sml_tk</B> also supports grid packing, which means
that you also place widgets in a specified row and column of a grid
within a container. You can choose the packing algorithm using the
<TT>Pack</TT> or <TT>Grid</TT> constructor of the type <TT>Widgets</TT>,
which is used to specify the initial content of a container
(containers in <B>sml_tk</B> are <TT>Frame</TT> as a normal container
widget, <TT>TAWidget</TT> for widgets within annotated texts, <TT>CWidget</TT>
for widgets within canvases, and of course windows). Once chosen you
can not change the applied packing algorithm. The programmer is
strongly encouraged to read chapter 17 of [Oust94] and try out some
of the examples, as the Tk packer exhibits a somewhat intractable
behaviour with occasionally rather surprising results; hence a
certain amount of experimentation and experience will not go amiss. 
</P>
<P>Bear in mind that 
</P>
<UL>
	<LI>pack information, once specified for a
	given widget, cannot be changed; and
	<LI>pack information not specified is left to Tk to use its default
	values.
</UL>
<P><B>sml_tk</B> implements a basic subset of Tk's pack options and
possibilities. These are: 
</P>
<PRE> datatype Edge = Top | Bottom | Left | Right
 datatype Style = X | Y | Both
 datatype StickyKind = N | S | E | W | NS | NE | NW | SE | SW | EW | NSE | NSW | NEW | SEW | NSEW

 datatype Pack = Expand of bool
               | Fill of Style
               | PadX of int
               | PadY of int
               | Side of Edge
               | Column of int
               | Row of int
               | Sticky of StickyKind</PRE><H4>
3.1.7. The core of <B>sml_tk</B>: Widgets and their Components</H4>
<P>Widgets (and their components) are the most important and powerful
datatype of <B>sml_tk</B> (and Tk). They are the basic building
blocks of any gui. 
</P>
<P>The different types of widgets are explained in the chapter <I>A
guided Tour through Tk Widgets</I> in [Oust94]. <B>sml_tk</B> offers
one constructor for every widget type. Selector and update functions
on widgets are given where useful. 
</P>
<P>Some widgets like frames (a grouping of widgets), canvas widgets
(a &quot;drawing pad&quot;) and text widgets can contain either
widgets themselves, or items (canvas items or text annotations) which
contain widgets; this results in a mutually recursive, fairly lengthy
data type definition. 
</P>
<P>As remarked above, the <TT>Widget</TT>, <TT>CItem</TT> and
<TT>Annotation</TT> data types have some parameters which are only
intended as <I>initial</I> values. They appear in italics below. If
one wants to get the actual value of such an initial value, one has
to use a <TT>readXXX</TT> function rather than a <TT>getXXX</TT> or
<TT>selXXX</TT> function. 
</P>
<PRE>datatype Widget =
 Frame of {widId : WidId, widgets : Widgets,
           packings : Pack list, configs : Configure list,
           bindings : Binding list}
 | Message of {widId : WidId, packings : Pack list,
               configs : Configure list, bindings : Binding list}
 | Label of {widId : WidId, packings : Pack list,
             configs : Configure list, bindings : Binding list}
 | Listbox of {widId : WidId, scrolltype : ScrollType,
               packings : Pack list, configs : Configure list,
               bindings : Binding list}
 | Button of {widId : WidId, packings : Pack list,
              configs : Configure list, bindings : Binding list}
 | Radiobutton of {widId : WidId, packings : Pack list,
                   configs : Configure list, bindings : Binding list}
 | Checkbutton of {widId : WidId, packings : Pack list,
                   configs : Configure list, bindings : Binding list}
 | Menubutton of {widId : WidId, mitems : MItem list,
                  packings : Pack list, configs : Configure list,
                  bindings : Binding list}
 | Entry of {widId : WidId, packings : Pack list,
             configs : Configure list, bindings : Binding list}
 | TextWid of {widId : WidId, scrolltype : ScrollType,
               annotext : AnnoText, packings : Pack list,
               configs : Configure list, bindings : Binding list}
 | Canvas of {widId : WidId, scrolltype : ScrollType,
              citems : CItem list, packings : Pack list,
              configs : Configure list, bindings : Binding list}
 | Popup of {widId : WidId, tearoff : bool, mitems : MItem list}
             mitems : MItem list}
 | ScaleWid of {widId : WidId, packings : Pack list,
                configs : Configure list, bindings : Binding list}
 and Widgets = Pack of (Widget list)
             | Grid of (Widget list)</PRE><P>
The type <TT>Widgets</TT> represents a collection of widgets, packed
either with Tk's Packer geometry manager, or with the Grid geometry
manager. Every widget has an identifier of the type <TT>WidId</TT>,
and pack information, configuration options and bindings. Other
parameters are widget specific, such as The following are useful
selector and update functions for <TT>Widget</TT>. (Note that you
can't update the widget identifier.) Some of these are necessarily
partial, and when applied to the wrong variant of widget will raise
the exception <TT>WIDGET</TT>. First, the ones applicable to all
widgets: 
</P>
<PRE> 
 val selWidgetId   : Widget -&gt; WidId
 val selWidgetBind : Widget -&gt; Binding list
 val selWidgetConf : Widget -&gt; Configure list
 val selWidgetPack : Widget -&gt; Pack list

 val updWidgetBind : Widget -&gt; Binding list -&gt; Widget
 val updWidgetConf : Widget -&gt; Configure list -&gt; Widget</PRE><P>
Functions specific to <TT>Canvas</TT>: val updWidgetPack : Widget -&gt;
Pack list-&gt; Widget 
</P>
<PRE> 
 val selCanvasItems      : Widget -&gt; CItem list
 val selCanvasScrollType : Widget -&gt; ScrollType

 val updCanvasItems      : Widget -&gt; CItem list -&gt; Widget
 val updCanvasScrollType : Widget -&gt; ScrollType -&gt; Widget</PRE><P>
Functions specific to <TT>TextWid</TT>: 
</P>
<PRE> 
 val selTextWidScrollType  : Widget -&gt; ScrollType
 val selTextWidText        : Widget -&gt; string
 val selTextWidAnnotations : Widget -&gt; Annotation list

 val updTextWidScrollType  : Widget -&gt; ScrollType -&gt; Widget
 val updTextWidAnnotations : Widget -&gt; Annotation list -&gt; Widget</PRE><H4>
Scrollbars</H4>
<P>As opposed to Tk, <B>sml_tk</B> does not offer a dedicated widget
type for scrollbars. Rather, for the widget types for which scroll
bars are useful- text widgets, canvas widgets, and list boxes-
scrollbars are provided automatically. Their location is determined
by the argument <TT>ScrollType</TT> in their constructor (where
<TT>NoneScb</TT> means no scroll bar at all). 
</P>
<PRE STYLE="margin-bottom: 0.2in"> datatype ScrollType = NoneScb | LeftScb | RightScb | TopScb | BotScb |
 LeftTopScb | RightTopScb | LeftBotScb | RightBotScb</PRE><P>
<A NAME="citems"></A>This also has the advantage that the programmer
need not to concern himself with the programming of the scroll bar. 
</P>
<H4>Canvas Items</H4>
<P>A <I>canvas</I> widget is a &quot;drawing pad&quot;. Drawing on a
canvas is done by placing the following <I>canvas items</I> onto it,
and as opposed to normal widgets, the location of the items is
exactly specified by means of coordinates, rather than left to a
packing algorithm. In the toolkit library, canvas widgets have been
used to implement a drag&amp;drop package and a generic user
interface (see <A HREF="#toolkit">section 4</A>). 
</P>
<P><B>sml_tk</B> provides all types of canvas items found in Tk.
These are: 
</P>
<PRE> datatype CItem =
 CRectangle of {citemId : CItemId, <I>coord1 : Coord</I>, <I>coord2 : Coord</I>,
                configs : Configure list, bindings : Binding list}
 | COval of {citemId : CItemId, <I>coord1 : Coord</I>, <I>coord2 : Coord</I>,
             configs : Configure list, bindings : Binding list}
 | CLine of {citemId : CItemId, <I>coords : Coord list</I>,
             configs : Configure list, bindings : Binding list}
 | Cpoly of {citemId : CItemId, <I>coords : Coord list</I>,
             configs : Configure list, bindings : Binding list}
 | CText of {citemId : CItemId, <I>coord : Coord</I>,
             configs : Configure list, bindings : Binding list}
 | CIcon of {citemId : CItemId, <I>coord : Coord</I>, iconkind : IconKind,
             configs : Configure list, bindings : Binding list}
 | CWidget of {citemId : CItemId, <I>coord : Coord</I>, widgets : Widgets,
               configs : Configure list, bindings : Binding list}
 | CTag of {citemId : CItemId, citemIds : CItemId list}</PRE><P>
As already noted above, italic parameters are the initial value.
Coordinates as arguments of the constructors allow convenient
specification of the initial position. 
</P>
<P>The following are the selector and update functions for <TT>CItem</TT>.
Again, some of them will be necessarily partial and when applied to
the wrong type of widget will raise an exception <TT>CITEM</TT>.
First, the functions applicable to most or all canvas items: 
</P>
<PRE> val selItemId : CItem -&gt; CItemId
 val selItemCoords : CItem -&gt; Coord list
 val selItemConf   : CItem -&gt; Configure list
 val selItemBind   : CItem -&gt; Binding list

 val updItemCoords : CItem -&gt; Coord list -&gt; CItem
 val updItemConf   : CItem -&gt; Configure list -&gt; CItem
 val updItemBind   : CItem -&gt; Binding list -&gt; CItem</PRE><P>
The following are specific to <TT>CIcon</TT>: 
</P>
<PRE> val selItemIcon : CItem -&gt; IconKind

 val updItemIcon : CItem -&gt; IconKind -&gt; CItem</PRE><P>
Within a <TT>CIcon</TT> item one can have the same bitmaps and images
as presented in <A HREF="#icons">section 3.1.5</A>. 
</P>
<P>The following are specific to <TT>CWidget</TT>: 
</P>
<PRE> val selItemWidId : CItem -&gt; WidId
 val selItemWidgetConf : CItem -&gt; Configure list
 val selItemWidgets : CItem -&gt; Widget list

 val updItemWidgetConf : CItem -&gt; Configure list -&gt; CItem
 val updItemWidgets : CItem -&gt; Widget list -&gt; CItem</PRE><P>
<TT>CWidget</TT> allows widgets within canvas items. Tk offers to
have one widget within a <I>window item</I>. We found it useful to
have more than one, so an <B>sml_tk</B> widget canvas item contains a
list of widgets, which are placed within a frame widget. The <TT>WidId</TT>
and <TT>Configuration</TT> arguments of the <TT>CWidget</TT>
constructor refer to this frame widget. The identifier for the frame
widget must be obtained by using the function <TT>newCItemFrameId</TT>
(see <A HREF="#ids">section 3.2.1</A>). 
</P>
<P>The following functions are specific for <TT>CTag</TT>: 
</P>
<PRE> val selItemItems : CItem -&gt; CItemId list

 val updItemItems : CItem -&gt; CItemId list -&gt; CItem</PRE><P>
<TT>CTag</TT> is only a very weak way of structuring canvas items.
Many of the operations on <TT>CItems</TT> are not applicable to <TT>CTag</TT>,
but e.g. <TT>moveCItem</TT> and <TT>setCItemCoords</TT> are, giving a
convenient way of moving about groups of canvas items. 
</P>
<H4><A NAME="annotations"></A>Text Annotations and Annotated Texts</H4>
<P>Text annotations are bindings and configurations for specific
parts of text within a text widget. They can be used for two
purposes, corresponding to the two variants of the data type
<TT>Annotation</TT> below: 
</P>
<UL>
	<LI>First, to have different fonts or
	styles, or even bindings, for parts of the text. By associating
	bindings with regions of text, one can implement hyperlink-like
	structures as in HTML (but the action bound to a hyperlink can be
	arbitrary).
	<LI>Second, to have subwidgets embedded within text widgets (to
	continue the HTML analogy, embedded widgets allow the design of
	form-like texts, but again far more versatile)
</UL>
<P><A NAME="mark"></A>Positions or regions within a text are
specified with the data type <TT>Mark</TT>. For historical reasons,
<B>sml_tk</B>'s marks are Tk's indices. For details, see [Oust94]
section 19.6. 
</P>
<PRE> datatype Mark = Mark of int (* line number [1..] *)
                        * int (* char number [0..] *)
    | MarkToEnd of int (* end of line i *)
    | MarkEnd (* end of text *)


 and Annotation =
 TATag of {annId : AnnId, marks : (Mark * Mark) list,
           configs : Configure list, bindings : Binding list}
 | TAWidget of {annId : AnnId, mark : Mark, widId : WidId,
           widgets : Widgets, configs1 : Configure list,
           configs2 : Configure list, bindings : Binding list}</PRE><P>
As already noted italic arguments are only initial values. The
position arguments of the constructors allow convenient specification
of their initial position. 
</P>
<P>The following are the selector and update functions for
<TT>Annotation</TT>. First, those that are applicable to both
variants of annotations: 
</P>
<PRE> val selAnnotationId : Annotation -&gt; AnnId
 val selAnnotationConf : Annotation -&gt; Configure list
 val selAnnotationBind : Annotation -&gt; Binding list
 val selAnnotationMarks : Annotation -&gt; (Mark * Mark) list

 val updAnnotationConf : Annotation -&gt; Configure list -&gt; Annotation
 val updAnnotationBind : Annotation -&gt; Binding list -&gt; Annotation</PRE><P>
<TT>selAnnotationMarks</TT> applied to a <TT>TAWidget</TT> returns a
singleton list containing a pair of two marks both equal to the
position of the widget annotation, i.e. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> selAnnotationMarks(TAWidget(_,p,_,_,_,_,_)) = [(p, p)]</PRE><P>
The following functions are specific to <TT>TAWidget</TT> and will
raise an exception <TT>ANNOTATION</TT> when applied to <TT>TATag</TT>.
</P>
<PRE> val selAnnotationWidId : Annotation -&gt; WidId
 val selAnnotationWidgets : Annotation -&gt; Widget list
 val selAnnotationWidgetConf : Annotation -&gt; Configure list

 val updAnnotationWidgets : Annotation -&gt; Widget list -&gt; Annotation</PRE><P>
<TT>TAWidget</TT> allows to embed widgets within a text. Tk offers to
have one widget within a <I>window annotation</I>. We found it useful
to have more than one, so an <B>sml_tk</B> widget annotation contains
a list of widgets, which are placed within a frame widget. The <TT>WidId</TT>
and <TT>Configuration</TT> arguments of the <TT>TAWidget</TT>
constructor refer to this frame widget. The identifier for the frame
widget must be obtained by using the function <TT>newAnnotationFrameId</TT>
(see <A HREF="#ids">section 3.2.1</A>). 
</P>
<H4><A NAME="anno_text"></A>Annotated Texts</H4>
<P>Annotated texts consist of a text, given by a string, and a list
of annotations within that text. They are provided as a separate
datatype because this way they can be treated abstractly; e.g. there
is a function which concatenates two annotated texts, adjusting the
annotations in the second text (see <A HREF="#anno_texts">section
3.2.9</A>). The first, optional argument of the constructor <TT>AnnoText</TT>
in the following is the length of the text (in lines and columns); if
it is not given, it will be calculated on a by-need basis. 
</P>
<PRE> and AnnoText =
 AnnoText of {len : (int* int) Option.option, str : string,
 annotations : Annotation list}</PRE><P>
The selectors and update functions for annotated texts are 
</P>
<PRE> val selText : AnnoText -&gt; string
 val selAnno : AnnoText -&gt; Annotation list
 val updAnno : AnnoText -&gt; Annotation list -&gt; AnnoText</PRE><P>
Annotated texts can be conveniently produced with <B>sml_tk</B>'s
markup language and the generic parser provided for it (see <A HREF="#markup_parser">section
4.2</A>), which alleviates the need to meticulously count lines and
columns within a text. 
</P>
<H4><A NAME="mitems"></A>Menu Items</H4>
<P>A menu is a list of the following items: 
</P>
<PRE> and MItem = MCheckbutton of (Configure) list
            | MRadiobutton of (Configure) list
            | MCascade of MItem list * Configure list
            | MSeparator
            | MCommand of (Configure) list</PRE><P>
These correspond to the Tk type. Note that for <TT>MCheckbuttons</TT>
and <TT>MRadiobutton</TT>, a Tcl variable has to be specified (using
the <TT>Variable</TT> configuration option) holding the status of the
check or radio button. Their current status can be read using
<TT>readVarValue</TT> (see <A HREF="#tclvalues">section 3.2.10</A>
below). Following are the selectors for <TT>MItem</TT>: 
</P>
<PRE> val selMCommand : MItem -&gt; SimpleAction
 val selMRelief : MItem -&gt; RelKind
 val selMText : MItem -&gt; string
 val selMWidth : MItem -&gt; int
 val selMItemConfigure : MItem -&gt; Configure list</PRE><H4>
3.1.8. Windows</H4>
<P>A window is a quadruple of a window identifier, a list of window
manager options, its constituting widgets, and a <TT>SimpleAction</TT>
that is evaluated just after the creation of the window. The latter
can be used for initialisation of the widgets in the window, e.g.
listboxes or text widgets can be filled with an initial content.
Windows are created with the following function: 
</P>
<PRE STYLE="margin-bottom: 0.2in"> type Window
 val mkWindow : {winId : WinId,
 config : WinConfigure list,
 widgets : Widgets,
 bindings: Binding list,
 init : SimpleAction} -&gt; Window</PRE><P>
Identifiers for windows can be obtained by the functions <TT>newWinId</TT>
or <TT>mkWinId</TT> (see <A HREF="#ids">section 3.2.1</A>). 
</P>
<P>The selector functions for <TT>Window</TT> are: 
</P>
<PRE> val selWindowAction : Window -&gt; SimpleAction
 val selWindowConfigures : Window -&gt; WinConfigure list
 val selWindowWidgets : Window -&gt; Widget list
 val selWindowWinId : Window -&gt; WinId</PRE><P>
The type <TT>WinConfigure</TT> provides a subset of the window
manager options for windows, corresponding to the arguments of Tk's
<TT>wm</TT> command (see chapter 22 of [Oust94]): 
</P>
<PRE> datatype UserKind =
 User
 | Program

 datatype WinConfigure =
 WinAspect of int * int * int *int (* xthin/ythin xfat/yfat *)
 | WinGeometry of ((int * int) Option.option) (* width x height *)
 * ((int * int) Option.option) (* xpos x ypos *)
 | WinMaxSize of int * int (* width * height *)
 | WinMinSize of int * int
 | WinPositionFrom of UserKind
 | WinSizeFrom of UserKind
 | WinTitle of string
 | WinGroup of WinId (* window / leader *)
 | WinTransient of WinId Option.option
 | WinOverride of bool</PRE><P>
A window title must only contain printable characters (space up to
~). See also the function <TT>checkWinTitle</TT> in <A HREF="#checks">section
3.2.13</A>. 
</P>
<P>The selector functions for <TT>WinConfigure</TT> are: 
</P>
<PRE> val selWinAspect : Window -&gt; (int * int * int * int) option
 val selWinGeometry : Window -&gt;
 (((int * int) option) *
 ((int * int) option) ) option
 val selWinMaxSize : Window -&gt; (int * int) option
 val selWinMinSize : Window -&gt; (int * int) option
 val selWinPositionFrom : Window -&gt; UserKind option
 val selWinSizeFrom : Window -&gt; UserKind option
 val selWinTitle : Window -&gt; Title option
 val selWinGroup : Window -&gt; WinId option
 val selWinTransient : Window -&gt; WinId option option
 val selWinOverride : Window -&gt; bool option</PRE><H3>
3.2. The Signature <TT>SML_TK</TT></H3>
<P>This section describes the functions from the signature <TT>SML_TK</TT>.
Whereas the data types and functions from the signature <TT>TK_TYPES</TT>
generate the term structure specifying the <I>initial appearance</I>
of windows, widgets and other elements of the user interface, the
functions from this section are primarily used to control the <I>runtime
behaviour</I> of the application. 
</P>
<P><b>sml_tk</b>'s runtime behaviour is centred around the concept
of an <I>event loop</I>. This means that after building the GUI as
specified by a list of initial windows (see <TT><A HREF="#eventloop">startTcl</A></TT>
below), <B>sml_tk</B> enters a loop waiting for <I>events</I> from
the user sent to the graphical display. They are interpreted
internally in Tk, passed to&nbsp;<B><SPAN STYLE="font-style: normal">sml_tk</SPAN></B>
and then processed by calling ML functions provided by the
programmer. In other words, <B>sml_tk</B> is running as a <I>reactive
system</I>, since the application merely <I>reacts</I> to user
interaction. These reactions can be specified as 
</P>
<UL>
	<LI>initialisation functions (for
	windows),
	<iLI><TT>Command</TT> configurations, or
	<LI>event bindings.
</UL>
<P><A NAME="other_apps"></A>Technically, this means that <B>sml_tk</B>
keeps track which ML function is bound to which event. The wish is
configured to send a string identifying the particular event when it
occurs, and <B>sml_tk</B> maps this string to the corresponding ML
function, which is then executed. 
</P>
<H4>3.2.1. Names and Identifiers</H4>
<P>In Tk, windows and widgets are referred to by their pathnames. In
<B>sml_tk</B>, windows and widgets are referred to by unique
<I>identifiers</I>. The following operations produce fresh
identifiers for windows, widgets, canvas items, frames for widgets
within canvas items, text annotations and frames for widgets within
>text annotations. The <TT>mkXX</TT> variants can be used to generate
more meaningful names, for the advanced programmer analyzing the
logfile (see the <A HREF="#appx">appendix</A>). 
</P>
<PRE> val newWinId : unit -&gt; TkTypes.WinId
 val newWidgetId : unit -&gt; TkTypes.WidId
 val newCItemId : unit -&gt; TkTypes.CItemId
 val newCItemFrameId : unit -&gt; TkTypes.WidId
 val newAnnotationId : unit -&gt; TkTypes.AnnId
 val newAnnotationFrameId : unit -&gt; TkTypes.WidId

 val mkWinId : string -&gt; TkTypes.WinId
 val mkCItemId : string -&gt; TkTypes.CItemId
 val mkWidgetId : string -&gt; TkTypes.WidId
 val mkFrameId : string -&gt; TkTypes.WidId</PRE><P>
Sometimes it is useful to generate names for widget identifiers from
given ones in a reconstructible way. This can be done using the
following function: 
</P>
<PRE STYLE="margin-bottom: 0.2in"> fun subWidId(w, str)= w ^ str</PRE><P>
The programmer should take great care not to use one identifier for
more than one window (widget, canvas item, etc), and in particular
should not use identifiers other than those obtained by the above
functions. 
</P>
<H4><A NAME="eventloop"></A>3.2.2. Starting and Terminating <B>sml_tk</B></H4>
<P>The following four functions control <B>sml_tk</B>'s event loop,
in particular start and termination of <B>sml_tk</B>: 
</P>
<PRE> val startTcl : TkTypes.Window list -&gt; unit
 val startTclExn : TkTypes.Window list -&gt; string

 val exitTcl : unit -&gt; unit

 val resetTcl : unit -&gt; unit</PRE><P>
<TT>startTcl</TT> takes the main window description and starts the
event loop- i.e. it builds and displays the specified list of windows
(with all their widgets and subcomponents), and then waits and reacts
to user interaction until either <TT>exitTcl</TT> is called, or the
main window is closed. 
</P>
<P><TT>startTclExn</TT> does the same as <TT>startTcl</TT>, but
additionally catches any exceptions which are raised within <B>sml_tk</B>
and prints their associated string value, detailing the nature of the
failure leading to the exception (see <A HREF="#exceptions">section
3.1.2</A> above). 
</P>
<P><TT>resetTcl</TT> has to be called before the application can be
started again after it was interrupted irregularly, either by a user
interruptor by raising an exception. There are two forms of interupts
that can be sent by the user to the main window: either &lt;CTRL-C&gt;
is pressed which will result in an interuption of the current
evaluation of a function bound to an event and continue with the
eventloop,or &lt;CTRL-\&gt; pressed which will result in a break of
the eventloop and kill the user interface. 
</P>
<H4>3.2.3. Windows</H4> <P>Opening a window with <TT>openWindow</TT>
displays the window on the screen and adds it to the GUI state; for
the main window, this is done by <TT>startTcl</TT>. An attempt to open
a window with a window id equal to that of an already open window
results in an error. The function <TT>occursWin</TT> can be used to
find out if a window with a specific id has already been opened.
</P>
<P>A window is closed with the function <TT>closeWindow</TT>. Closing
the main window results in a call to <TT>exitTcl</TT>; this is the
preferred way to terminate an <B>sml_tk</B> application. 
</P>
<PRE> val openWindow : TkTypes.Window -&gt; unit
 val occursWin : TkTypes.WinId -&gt; bool
 val closeWindow : TkTypes.WinId -&gt; unit</PRE><P>
The functions <TT>getWindow</TT> and <TT>getAllWindows</TT> can be
used the extract information about some or all windows from the GUI
state. <TT>changeTitle</TT> changes the title of the window (as
appearing in its title bar). 
</P>
<PRE> val getWindow : TkTypes.WinId -&gt; TkTypes.Window
 val getAllWindows : unit -&gt; TkTypes.Window list

 val changeTitle : TkTypes.WinId -&gt; TkTypes.Title -&gt; unit</PRE><H4>
<A NAME="widget_ops"></A>3.2.4. General Operations on Widgets</H4>
<P>The function <TT>getWidget</TT> retrieves the widget specified by
the identifier <TT>WidId</TT> from the GUI state. 
</P>
<PRE STYLE="margin-bottom: 0.2in"> val getWidget : TkTypes.WidId -&gt; TkTypes.Widget</PRE><P>
Widgets can also be added or deleted dynamically. <TT>addWidget</TT>
adds the widget to the window specified by <TT>WinId</TT> into the
widget specified by <TT>WidId</TT>. The latter widget has to be a
frame widget, and the widget to be added will be inserted at the end
of its list of subwidgets. <TT>delWidget</TT> deletes the specified
widget. 
</P>
<P>An example for the use of <TT>addWidget</TT> and <TT>delWidget</TT>
can be found in <TT>src/tests+examples/big_ex.sml</TT>. 
</P>
<PRE> val addWidget : TkTypes.WinId -&gt; TkTypes.WidId -&gt; TkTypes.Widget -&gt; unit
 val delWidget : TkTypes.WidId -&gt; unit</PRE><P>
Note that it is not possible to add a widget to a window without any
frames in it. In particular, it is not possible to add widgets to an
initially empty window- clearly a pathological situation. If you
really want a window which initially does not contain any widget,
consider using only an invisible frame. 
</P>
<P>The visual appearance and the behaviour of a widget is modified by
the configuration options and binding of the widget. This is is
achieved with the following functions: <TT>setBind</TT> and
<TT>setConf</TT> completely overwrite the bindings or configuration
options for the specified widget, whereas <TT>addBind</TT> and
<TT>addConf</TT> replace bindings or configuration options of the same
kind, add new ones and leave the rest untouched.
</P>
<PRE> val addBind : TkTypes.WidId -&gt; TkTypes.Binding list -&gt; unit
 val addConf : TkTypes.WidId -&gt; TkTypes.Configure list -&gt; unit

 val setBind : TkTypes.WidId -&gt; TkTypes.Binding list -&gt; unit
 val setConf : TkTypes.WidId -&gt; TkTypes.Configure list -&gt; unit</PRE><P>
The functions <TT>getTextWidWidgets</TT> and <TT>getCanvasWidgets</TT>
allow the convenient extraction of all top level widgets within text
or canvas widgets; they are undefined for all other variants of
widgets. 
</P>
<PRE> val getTextWidWidgets : TkTypes.Widget -&gt; TkTypes.Widget list
 val getCanvasWidgets : TkTypes.Widget -&gt; TkTypes.Widget list</PRE><P>
You can also disable certain widgets using the <TT>Active</TT>
configure option, which can also be set when the widget is already
constructed (by the <TT>addConf</TT> or <TT>setConf</TT> functions).
You can apply the <TT>Active</TT> configure option to buttons,
radiobuttons, checkbuttons, menubuttons, scale widgets, entry
widgets, and text widgets. 
</P>
<H4>3.2.5. Configuration Options and Bindings for Widgets</H4>
<P>The functions in this section are for convenience only. They allow
the easy extraction of parts of configuration options or bindings for
a widget specified by its <TT>WidId</TT>. 
</P>
<PRE> (* are all derived from getWidget *)
 val getConf : TkTypes.WidId -&gt; TkTypes.Configure list
 val getRelief : TkTypes.WidId -&gt; TkTypes.RelKind
 val getCommand : TkTypes.WidId -&gt; TkTypes.SimpleAction
 val getBindings : TkTypes.WidId -&gt; TkTypes.Binding list
 val getWidth : TkTypes.WidId -&gt; int
 val getMCommand : TkTypes.WidId -&gt; int list -&gt; TkTypes.SimpleAction</PRE><P>
For example, <TT>getConf</TT> is the composition of <TT>getWidget</TT>
and <TT>selWidgetConf</TT>. 
</P>
<H4>3.2.6. Operations for Widgets with Text</H4>
<P>This section describes some uniform operations for widgets
containing text. These encompass mainly list boxes and entry widgets.
</P>
<P>A position within text in these widgets is specified with the
datatype <TT>Mark</TT> (see <A HREF="#mark">section 3.1.7</A> above)
is used, with the following conventions: 
</P>
<UL>
	<li>for a list box, the position is always
	<TT>Mark(n,_)</TT> where <TT>n</TT> is the index of the selected
	item in the list box, and the second argument is irrelevant;
	<li>for an entry widget, positions are (at the moment) ignored; any
	operation will always affect the whole text.
</UL>
<H4>Manipulation of Text</H4>
<P>These functions are mainly geared towards list boxes and entry
widgets. For text widgets, we recommend the funtions detailed <A HREF="#insannotext">below</A>,
since they take annotated texts as arguments, and in particular
handle read-only text widgets correctly - note that using <TT>insertText</TT>
etc. on a read-only text widget will fail! 
</P>
<P>The functions <TT>insertText</TT> and <TT>insertTextEnd</TT>
insert text into the widget specified by <TT>WidId</TT> at either the
specified position, or the end. The function <TT>clearText</TT>
deletes all text from the specified widget, and <TT>deleteText</TT>
deletes the specified region of text from the specified widget. 
</P>
<PRE> val insertText : TkTypes.WidId -&gt; string -&gt; TkTypes.Mark -&gt; unit
 val insertTextEnd : TkTypes.WidId -&gt; string -&gt; unit

 val clearText : TkTypes.WidId -&gt; unit
 val deleteText : TkTypes.WidId -&gt; TkTypes.Mark * TkTypes.Mark -&gt; unit</PRE><P>
Text in widgets of these kinds can be changed interactively by the
user. Since this change is not reflected in the GUI state, the
following functions have to be used to obtain the actual text (or
region of text) from a widget. 
</P>
<PRE> val readText : TkTypes.WidId -&gt; TkTypes.Mark * TkTypes.Mark -&gt; string
 val readTextAll : TkTypes.WidId -&gt; string</PRE><H4>
<A NAME="selposrange"></A>Selection of Positions and Ranges</H4>
<P>The user may <I>select</I> a position or a range of text within
widgets containing text (see <A HREF="#selection">section 3.2.15</A>
below). <TT>readCursor</TT> returns the position of the cursor, and
<TT>readSelRange</TT> returns the regions of the selection as a list
of pairs of positions (denoting start and end of the selected
regions). 
</P>
<PRE> val readCursor : TkTypes.WidId -&gt; TkTypes.Mark
 val readSelRange : TkTypes.WidId -&gt; (TkTypes.Mark * TkTypes.Mark) list</PRE><P>
For example, if <TT>wl</TT> is a list box, <TT>readCursor wl</TT>
returns <TT>Mark(n,_)</TT> where <TT>n</TT> is the index of the list
box currently containing the cursor. 
</P>
<P><A NAME="insannotext"></A>Before using the function <TT>readSelRange</TT>
it should be checked with the function <TT>readSelWindow</TT> (see
<A HREF="#selection">section 3.2.15</A> below) that the user has
indeed selected some text within the widget. 
</P>
<H4>Operations for Text Widgets</H4>
<P>To get and change the current state (read-only or user editable)
of a text widget, use the following functions: 
</P>
<PRE> val readTextWidState : WidId -&gt; bool
 val setTextWidReadOnly : WidId -&gt; bool -&gt; unit</PRE><P>
To manipulate the contents of text widgets, the following functions
are provided. They work on read-only text widgets, and they take
annotated texts as arguments, adjusting the annotations in the text
as necessary when inserting it. 
</P>
<PRE> val clearAnnoText : WidId -&gt; unit
 val replaceAnnoText : WidId -&gt; AnnoText-&gt; unit
 val deleteAnnoText : WidId -&gt; Mark* Mark-&gt; unit
 val insertAnnoText : WidId -&gt; AnnoText-&gt; Mark-&gt; unit
 val insertAnnoTextEnd : WidId -&gt; AnnoText-&gt; unit (* use discouraged-- very inefficient! *)</PRE><P>
The function <TT>insertAnnoTextEnd</TT> has been implemented in the
obvious way, which involves reading the content of the text widget
and counting its length, and is far more inefficient that in has to
be. If you find you really need this function, consider contributing
a more efficient implementation to <B>sml_tk</B>. Until then,
restrict its usage to cases where it cannot be avoided. 
</P>
<H4>3.2.7. Canvases and Canvas Items</H4>
<P>The following functions are the counterpart to the functions on
widgets in <A HREF="#widget_ops">section 3.2.4</A> above for canvas
items. They allow the dynamic addition of canvas items to a canvas,
their removal from it and the reconfiguration of canvas item bindings
and configurations. Canvas Items are identified by the <TT>WidId</TT>
of the canvas within which they appear, and their <TT>CItemId</TT>
identifier. 
</P>
<PRE> val getCItem : TkTypes.WidId -&gt;
                     TkTypes.CItemId -&gt;
                     TkTypes.CItem

 val addCItem :     TkTypes.WidId -&gt;
                    TkTypes.CItem -&gt; unit
 val delCItem :     TkTypes.WidId -&gt;
                    TkTypes.CItemId -&gt; unit

 val getCItemBind : TkTypes.WidId -&gt;
                    TkTypes.CItemId -&gt;
                    TkTypes.Binding list
 val getCItemConf : TkTypes.WidId -&gt;
                    TkTypes.CItemId -&gt;
                    TkTypes.Configure list

 val addCItemBind : TkTypes.WidId -&gt;
                    TkTypes.CItemId -&gt;
                    TkTypes.Binding list -&gt; unit
 val addCItemConf : TkTypes.WidId -&gt;
                    TkTypes.CItemId -&gt;
                    TkTypes.Configure list -&gt; unit</PRE><P>
As already noted above the coordinates given to the constructor of a
canvas item are only its initial values; the actual values can be
read with <TT>readCItemCoords</TT>. <TT>setCItemCoords</TT> sets new
coordinates, and <TT>moveCItem</TT> moves an item by the specified
distance. 
</P>
<PRE> val readCItemCoords : TkTypes.WidId -&gt;
                            TkTypes.CItemId -&gt;
                            TkTypes.Coord list
 val setCItemCoords :       TkTypes.WidId -&gt;
                            TkTypes.CItemId -&gt;
                            TkTypes.Coord list -&gt;
                            unit
 val moveCItem :            TkTypes.WidId -&gt;
                            TkTypes.CItemId -&gt;
                            TkTypes.Coord -&gt;
                            unit</PRE><P>
Note <TT>setCItemCoords</TT> does not work for <TT>CTag</TT> canvas
items, but <TT>moveCItem</TT> does. Also, deleting a <TT>CTag</TT>
item does not delete the subitems, only the tag item itself, and
adding bindings to a <TT>CTag</TT> item is somewhat useless, since
they are not displayed as such --- you most probably want to add the
bindings to the subitems. 
</P>
<P>The following functions return the height and width of a canvas
item in a uniform way. For items of type <TT>CIcon</TT> with an image
content, this is the only way to get their actual width and height.
Note that the canvas item has to be displayed on a canvas to use
these functions. 
</P>
<PRE> val readCItemHeight : TkTypes.WidId -&gt; TkTypes.CItemId -&gt; int
 val readCItemWidth : TkTypes.WidId -&gt; TkTypes.CItemId -&gt; int</PRE><H4>
3.2.8. Annotations for Text Widgets</H4>
<P>The same set of basic functions as for canvas items is available
for text annotations in text widgets. Text annotations are identified
by the <TT>WidId</TT> of the parent text widget and an <TT>AnnId</TT>
identifier. 
</P>
<PRE> val getAnnotation :    TkTypes.WidId -&gt;
                         TkTypes.AnnId -&gt;
                         TkTypes.Annotation

 val addAnnotation :     TkTypes.WidId -&gt;
                         TkTypes.Annotation -&gt; unit
 val delAnnotation :     TkTypes.WidId -&gt; 
                         TkTypes.AnnId -&gt;unit

 val getAnnotationBind : TkTypes.WidId -&gt;
                         TkTypes.AnnId -&gt;
                         TkTypes.Binding list
 val getAnnotationConf : TkTypes.WidId -&gt;
                         TkTypes.AnnId -&gt;
                         TkTypes.Configure list

 val addAnnotationBind : TkTypes.WidId -&gt;
                         TkTypes.AnnId -&gt;
                         TkTypes.Binding list -&gt; unit
 val addAnnotationConf : TkTypes.WidId -&gt;
                         TkTypes.AnnId -&gt;
                         TkTypes.Configure list -&gt; unit</PRE><P>
The actual position and regions of annotations can be changed
dynamically by the user (by editing the text in the widget); the
function <TT>readAnnotationMarks</TT> reads their actual values.
<TT>readSelection</TT> returns the location of selected text within
the particular text widget. Before using this function, it should be
checked with the function <TT>readSelWindow</TT> <A HREF="#selection">(section
3.2.15)</A> that the user has really selected some regions in this
widget, otherwise the exception <TT>TCL_ERROR</TT> will be raised. 
</P>
<PRE> val readAnnotationMarks : TkTypes.WidId -&gt;
                                TkTypes.AnnId -&gt;
                                (TkTypes.Mark * TkTypes.Mark) list

 val readSelection : TkTypes.WidId -&gt;
                    (TkTypes.Mark * TkTypes.Mark) list</PRE><P>
<B>Caution:</B> Since the user can interactively edit the text, it is
possible that annotations are deleted without <B>sml_tk</B> noticing.
Hence, you cannot be sure that an annotation, although defined and
displayed, still exists, and referring to it may lead to an error.
There are three ways to handle this situation: 
</P>
<UL>
	<LI>setting the text widget option
	<TT>TextWidState</TT> to <TT>TextWidStateDisabled</TT>, so the user
	can no longer change the contents of a text widget;
	<LI>defining your own bindings for every
	destructive key stroke and deleting any annotations yourself;
	<LI>catching the exception resulting from referring to a deleted
	annotation.
</UL>
<H4><A NAME="anno_texts"></A>3.2.9 Annotated Texts</H4>
<P>For annotated texts the following utility functions are provided.
<TT>mkAT</TT> makes a string into an annotated text without any
annotations, <TT>mtAT</TT> is the empty annotated text, <TT>++</TT>
concatenates annotated texts, keeping track of the annotations. <TT>nlAT</TT>
appends a newline to the annotated text, and <TT>concatATWith</TT>
concatenates a list of annotated texts, interspersing them with the
given string. 
</P>
<PRE> val mkAT : string -&gt; TkTypes.AnnoText
 val mtAT : TkTypes.AnnoText

 infix 6 ++
 val ++ : TkTypes.AnnoText * TkTypes.AnnoText -&gt; TkTypes.AnnoText

 val nlAT : TkTypes.AnnoText -&gt; TkTypes.AnnoText
 val concatATWith : string -&gt; TkTypes.AnnoText list -&gt; TkTypes.AnnoText</PRE><H4>
3.2.10. Menu Widgets</H4>
<P>Menus items are widgets, and as such can be added or deleted from
a frame (containing other menu items, most likely) by the functions
<TT>addWidget</TT> and <TT>delWidget</TT> above. Currently, <B>sml_tk</B>
does not support the disabling of menus. 
</P>
<P>Pop-up menus are supported by the following two functions:
<TT>createAndPopUpMenu</TT> takes a pop-up menu widget and pops it up
at the specified coordinate, and <TT>popUpMenu</TT> pops up a menu at
the specified coordinate which has already been specified somewhere
else in the widget tree. The optional integer parameter is the index
of the menu item which should be below the mouse when the menu pops
up. 
</P>
<PRE> val createAndPopUpMenu : TkTypes.Widget -&gt;
                            int TkTypes.option -&gt;
                            TkTypes.Coord -&gt;
                            unit

 val popUpMenu : TkTypes.WidId -&gt;
                 int TkTypes.option -&gt;
                 TkTypes.Coord -&gt; unit</PRE><P>
<TT>src/tests+examples/popup_ex.sml</TT> is an example for the use of
popup menus. 
</P>
<H4><A NAME="tclvalues"></A>3.2.11. Buttons and Tcl Values</H4>
<P>As already noted in <A HREF="#mitems">section 3.1.7</A> above,
these two functions are needed in the context of check buttons or
radio buttons. The first argument is the variable name, the second
argument for <TT>setVarValue</TT> is the intended value. 
</P>
<PRE> val setVarValue : string -&gt; string -&gt; unit
 val readVarValue : string -&gt; string</PRE><H4>
3.2.12. Coordinates</H4>
<P><I>Coordinates</I> are pairs of integers. They can be added or
subtracted with <TT>addCoord</TT> and <TT>subCoord</TT>; <TT>smultCoord</TT>
is multiplication with a scalar. 
</P>
<PRE> type Coord= int* int
 val addCoord : TkTypes.Coord -&gt; TkTypes.Coord -&gt; TkTypes.Coord
 val subCoord : TkTypes.Coord -&gt; TkTypes.Coord -&gt; TkTypes.Coord
 val smultCoord : Coord-&gt; int-&gt; Coord</PRE><P>
A <I>rectangle</I> is given by two coordinates, specifying two of its
corners. <TT>inside p r</TT> returns true if the point at coordinate
<TT>p</TT> is inside the rectangle <TT>r</TT>, and <TT>intersect</TT>
checks wether the two rectangles intersect. <TT>moveRect</TT> moves a
rectangle by the specified coordinate (considered as a vector). 
</P>
<PRE> type Rect = Coord* Coord
 val inside : TkTypes.Coord -&gt; Rect -&gt; bool
 val intersect : Rect-&gt; Rect-&gt; bool
 val moveRect : Rect -&gt; TkTypes.Coord -&gt; Rect</PRE><H4>
Finally, show functions are provided as a convenience.</H4>
<PRE> val showCoord : Coord list -&gt; string
 val convCoord : string -&gt; Coord list
 val showRect : Rect -&gt; string</PRE><H4>
<A NAME="checks"></A>3.2.13. Checks</H4>
<PRE>
val checkWidId    : WidId -> bool
val checkWinId    : WinId -> bool
val checkWinTitle : TkTypes.Title -&gt; bool
</PRE><P>
These functions checks whether the argument is a
correct window id, widget id or window title. 
</P>
<P>Implicit checks of the widget configurations have been added. The
applied configurations are checked, when the widgets are packed. An
exception <TT>WIDGET</TT> will be raised, when bad configure options
are found. However, <b>sml_tk</b>'s checks are not as comprehensive as
one might hope for.  The exception <TT>TCL_ERROR</TT> is raised when
the wish returns a Tcl error- this happens in particular if an illegal
window (widget, canvas item, etc.) is passed to the wish.
</P>
<H4><A NAME="focus"></A>3.2.14. Focus and Grabs</H4>
<P>The functions <TT>focus</TT> and <TT>deFocus</TT> set and reset
the keyboard focus to the specified window. Please refer to chapter
21 in [Oust94] for an explanation of the Tk focus model. 
</P>
<PRE> val focus : TkTypes.WinId -&gt; unit
 val deFocus : TkTypes.WinId -&gt; unit</PRE><P>
With <TT>grab</TT> and <TT>deGrab</TT>, <I>modal interactions</I> can
be implemented in <B>sml_tk</B> (see chapter 24 of [Oust94]). A grab
&quot;claims ownership&quot; of the mouse and keyboard, such that all
subsequent events will go to the claiming window. A particular
example of this is a a window containing a dialog box the user is
required to answer before proceeding. 
</P>
<PRE> val grab : TkTypes.WinId -&gt; unit
 val deGrab : TkTypes.WinId -&gt; unit</PRE><P>
<A NAME="selection"></A>Be careful to alway release a grab with
<TT>deGrab</TT>; failing to do so can lead into unpleasant
situations. To prevent the worst case (completely freezing up the
display) global grabs are not provided by <B>sml_tk</B>, i.e. all
grabs are local. 
</P>
<H4>3.2.15. The Selection</H4>
<P>In window systems such as X windows, the user can <I>select</I>
regions of text by holding a mouse button and moving the mouse over
the region of text to be selected. This selection is display-wide,
and is called the <I>X selection</I> below. An application is said to
<I>own the selection</I> if a region in one of its windows is
selected. The function <TT>readSelWindow</TT> returns <TT>NONE</TT>
if the application does not own the X selection, and the identifiers
of the window and widget which own the X selection otherwise. Within
text widgets, list boxes and entry widgets, the X selection can be
accessed with the <TT>readSelRange</TT> 
</P>
<PRE STYLE="margin-bottom: 0.2in"> val readSelWindow : unit -&gt; (TkTypes.WinId * TkTypes.WidId) TkTypes.option</PRE><P>
Chapter 20 in [Oust94] explains the <I>X selection</I> in depth. 
</P>
<H4>3.2.16. Interrupt Handling</H4>
<P>To handle interrupts (<TT>CTRL-C</TT>), <B>sml_tk</B> uses a very
simple-minded broadcast model. Applications can register so-called
listeners, which are functions which are called when an interrupt
occurs (i.e. the user aborts an ongoing computation by hitting
<TT>CTRL-C</TT>). Such a listener is given by the abstract data type
<TT>intr_listener</TT>, and about the only thing we can do with that
is de-register it again (which means, of course, that it isn't called
anymore when an interrupt occurs). Typically, a listener will ensure
an application's state consistency - note that interrupts can occur
anywhere inside a function, so stateful computations may need to
reset the state to a consistent value. 
</P>
<PRE>type intr_listener

 val registerIntrListener : (unit-&gt; unit)-&gt; intr_listener
 val deregisterIntrListener : intr_listener-&gt; unit</PRE><P>
<A NAME="init-config"></A>Note that the user can also always type
<TT>CTRL-/</TT> to abort <B>sml_tk</B> altogether and return to the
SML toplevel. If you want to change this behaviour (or the keys they
are bound to), have a look at <TT>src/njml.sml</TT>.&nbsp; Note: this
 behaviour may not work correctly with all SML compilers (though it
 does with SML/NJ).
</P>

<H4>3.2.17. <B>sml_tk</B> Initialization and Configuration</H4>
<P>The <TT>init</TT> function initializes <B>sml_tk</B>: it sets the
basic configurations of <B>sml_tk</B> from the environment as
explained in <A HREF="#smltk_config">section</A>, and initializes the
fonts and the terminal. <B>It needs to be called before any sml_tk
application is started.</B> You can also initialize the fonts
separately and unconditionally (<TT>init</TT> only initializes the
fonts if the environment variable <TT>DISPLAY</TT> has changed.) 
</P>
<PRE> val init : unit -&gt; unit
 val initFonts : unit -&gt; unit</PRE><P>
The following functions can be used to read or update the current
values of the runtime configuration variables (see <A HREF="#config-runtime">).
Note that updates will be overwritten by the next call to <TT>init</TT></A>.
The only two interesting functions here will probably be <TT>getLibPath</TT>
to get the location of image files etc, and <TT>updLogfilePath</TT>
to switch on logging for one debug run of the system (see the
<A HREF="#appx">appendix</A>). 
</P>
<PRE> val getLibPath : unit -&gt; string
 val updLibPath : string -&gt; unit
 val getTclPath : unit -&gt; string
 val updTclPath : string-&gt; unit
 val getLogfilePath : unit-&gt; string
 val updLogfilePath : string-&gt; unit</PRE><H2>
<A NAME="toolkit"></A>4. The Toolkit Library</H2>
<P>The toolkit library offers two collection of modules which are not
part of the core of sml_tk, but offer additional functionality. The
first collection is called <i>Common Infrastructure</i> (CI) and
comprises utilities, abstract events, exchange mechanisms between
gui-components and common intercaces for visualizable elements that
are used and exchanged between various more astract gui-components.
The second collection called <i>Gui Components</i> (GC) and
contains a number of preconceived (and sometimes generic) widgets and
windows for a number of routine tasks in the implementation of gui's.
</P>
<P>In more detail, the <i>Common Infrastructure</i> contains: 
</P>
<UL>
	<LI> module clipboard, which allows
	the exchange of objects between different <B>sml_tk</B>
	applications, for example the Filer and GenGUI;</LI> 
	<LI>a module icons, which allows an
	abstract icon management;</LI> 
	<LI>a markup language parser
	facilitating the use of annotated texts;</LI> 
	<LI>a family of signatures and
	functors for representation and manipulation &quot;visualizable
	elements&quot; - called <I>objects </I>- that represent a common
	data model for some gui components </LI>
	<LI>a family of signatures for representing &quot;applications&quot;
	yielding abstract interfaces for the functional kernal to be plugged
	into a gui </LI>
</UL>
<P>Based on CI, the <I>Gui Components</I> comprise the following:
</P>
<UL>
	<LI>a module <TT>util_win</TT>, which</LI>
	implements some utility windows to display warnings, error messages,
	wait for user confirmation or enter some text; 
	<LI>a module <TT>lazy_trees</TT>
	yielding a widget for the incremental generation of hierarchical
	trees for navigation </LI>
	<LI>a module <TT>filer</TT>, which
	implements a browser for the file system, allowing the user to
	select specific files or directories (based on <TT>lazy_trees)</TT>;</LI>
	<LI> a module <TT>drag_and_drop</TT>,
	which extends a canvas (cf. above) to allow drag&amp;drop-style
	operations between the items on the canvas; </LI>
	<LI> a module <TT>tree_list</TT>
	yielding a widget for the incremental generation of hierarchical
	trees for navigation; <BR>(similar to <TT>lazy_trees</TT>, but in
        contrast to it, based
	on CI and providing more selection functionality); </LI>
	<LI>a module <TT>notepad</TT> built on
	<TT>tree_list</TT> as navigation throuh a hierarchy of
	drag&amp;drop-canvasses; </LI>
	<LI>a module <TT>tgen_gui </TT>(and
	its simpler version <TT>gen_gui</TT>) which is a generic user
	interface built on the notepad (or the drag&amp;drop-package resp.);</LI>
	<LI>a module <TT>table</TT> yields a
	widget displaying a table (organized in rows an colums) composed of
	editable entries;</LI> 
	<LI>a module <TT>tabs</TT> yields a
	widget displaying several sub-widgets in the style of register tabs,
	allowing to switch between the sub-widgets just by </LI>
	<LI>a module <tt>widget_box</tt> yields widget boxes,
	which are like list boxes, except they contain widgets,
	rather than text</LI>
</UL>
<P>The next five sections are concerned with the discription of CI,
while the rest of the chapter is devoted to the description of Gui
Components.</P>
<H3>4.1. Exchanging Objects: the Clipboard</H3>
<P>The clipboard module allows to interchange objects between
different applications, like the filer and GenGUI. 
</P>
<P>Its basic idea is that applications can put objects into the
clipboard, and other applications can get the objects previously put
into the clipboard. The actions of putting and getting are certified
by a <TT>TkEvent</TT>, and a subsequent get only retrieves the object
if the cursor root positions of the certifying events match. For
example, a put can be triggered by releasing the drag button outside
the window, and the get can be triggered by the cursor entering the
window. Then we would only want the get to retrieve the put object if
the cursor has not moved in between, i.e. the root position of the
<TT>TkEvents</TT> are equal. 
</P>
<P>The signature of the clipboard reads as follows: 
</P>
<PRE>signature CLIPBOARD =
 sig
 type obj

 exception Empty

 val get: TkTypes.TkEvent-&gt; obj
 val copy : TkTypes.TkEvent-&gt; obj
 val put: obj-&gt; TkTypes.TkEvent -&gt; (unit-&gt; unit)-&gt; unit

 val isEmpty: TkTypes.TkEvent -&gt; bool
 end</PRE><P>
<TT>get</TT> is as described above. The third argument to <TT>put</TT>
is a call-back function, which is called if a subsequent <TT>get</TT>
for the object succeeds. This can be used to ``pass'' objects from
one application to another - the call-back function would delete the
object from one application once another application has successfully
taken it out of the clipboard. <TT>copy</TT> takes the object out of
the clipboard <I>without</I> calling the call-back; hence if the
callback is used to delete an object once it appears elswhere, by
calling <TT>copy</TT> we would copy the object, rather than move it.
<TT>isEmpty</TT> is true if a subsequent <TT>get</TT> (or <TT>copy</TT>)
with the same event would be successful. An unsuccessful <TT>get</TT>
or <TT>copy</TT> (either because there is no object, or because the
two events do not match) will raise the exception <TT>Empty</TT>.
Further, any unsuccessful <TT>get</TT> or <TT>copy</TT> will empty
the clipboard. 
</P>
<P>As an example, consider the way the filer and GenGUI interchange
objects. The filer is a functor which has as its argument the
clipboard, and two functions converting files and directories into
clipboard objects (because it depends on the application GenGUI is
instantiated with how to convert a file name or directory name into
an object): 
</P>
<PRE>functor ClipFiler
 (structure M : sig val filter_files : string -&gt; string -&gt; bool;
 exception bad_regexp
 structure CB: CLIPBOARD
 val fileToObj : string* string-&gt; CB.obj
 val dirToObj : string-&gt; CB.obj
 end): FILER_SIG</PRE><P>
(At least, thuThe filer will call <TT>CB.put</TT> whenever the user releases the
mouse button after a file selection. (By the peculiarities of Tk's
event handling, even if the cursor has been moved over another window
in the meantime, the <TT>Release</TT> event will still go the filer.)
</P>
<P>Any application instantiating the GenGUI has to have a clipboard
substructure: 
</P>
<PRE>signature APPL_SIG =
 sig
 [...]
 structure CB : CLIPBOARD
 sharing type CB.obj = unit -&gt; object list
 end</PRE><P>
Whenever a cursor enters the construction area, a <TT>CB.put</TT> is
tried. If the cursor position matches the previous <TT>CB.get</TT>,
then the cursor has not moved in between: this means that the <TT>Enter</TT>
event has occurred immediately after a button release. (Note that if
the mouse is moved into the construction area with the mouse button
pressed, no <TT>Enter</TT> event is generated, only once the mouse
button is released.) If the <TT>CB.get</TT> is successful, the user
has dragged a file from the filer into the construction area, and
GenGUI will have the object appear at that position. Note how we pass
a closure rather than the actual object in order to avoid the
unnecessary creation of objects. 
</P>
<P>Note the the type sharing equation above is not legal according to
the SML97 standard, hence the real signature looks a bit more
complicated. </P>
<P>Finally, the clipboard has two sub-signatures, <TT>CLIPBOARD_R</TT>
and <TT>CLIPBOARD_W</TT>, which are for read-only and write-only
access to the clipboard. For example, in the above the argument of
the ClipFiler has actually write-only access to the clipboard, so the
line reads 
<pre>
structure CB: CLIPBOARD_W 
</pre>
<H3>4.2. Managing Icons</H3>
<P>Some gui-components such as <tt>GenGUI</tt> associate an <I>icon</I> with
every object, depending on its type and mode. The application has to
implement these icons, assigning an icon to every object type and
mode with the function <TT>icon: objtype* mode -&gt; Icons.icon</TT>.
The icon has to be implemented by the application, using the
structure <TT>Icons</TT> in the toolkit library, which has the
following export signature: 
</P>
<PRE>signature ICON_SIG =
 sig type icon

 val getIcon : string * string -&gt; icon

 val selWidth : icon -&gt; int
 val selHeight : icon -&gt; int

 val selImage : icon -&gt; SmlTk.IconKind
 val selHiLite : icon -&gt; SmlTk.IconKind
 val selOutline : icon -&gt; SmlTk.IconKind
 val selMicroline : icon -&gt; SmlTk.IconKind

 exception ICON end</PRE> <P> Every icon comes in four varieties:
normal, highlighted, outlined and microlined (i.e. wee). The
highlighted image is displayed to signal that an object is ready to
receive a drag&amp;drop operation (see above), the outlined image is
displayed when an object is not ready to receive any kind of
operation, the microlined object is used in the tree navigation
component, and the normal image is presented at all other times.
</P>
<P>The present implementation of icons assumes that all icons are Tk
file images (i.e. graphical formats such as GIF readily understood by
the wish). To create an icon, the function <TT>getIcon</TT> is called
with the directory the file image is in, and its file name. The
highlighted and outlined images are supposed to be in the same
directory, with the base file name of the normal image suffixed with
<TT>-hi</TT>, <TT>-out</TT> and <tt>-mic</tt> respectively (followed by the file
name extension). They are also supposed to be of the same size as the
normal image. Further, a data file with the same file name but the
extension <TT>data</TT> has to exist which contains, in two lines,
the width and height of the icon. (This is due to a catch 22 in the
image handling of Tcl/Tk and GenGUI - essentially, we cannot know how
large an image without displaying it, but we since we want to place
it on the notepad, we need to know how large it is before we do
that.) 
</P>
<P>For example, an application could have types of objects called
<TT>wotsits</TT> and assign icons to them by the following function
declaration 
</P>
<PRE>fun icon wotsits = getIcon(&quot;/home/me/example/icons&quot;, &quot;wotsit.gif&quot;)
 | icon ... = ...</PRE><P>
Then the directory <TT>/home/me/example/icons</TT> has to include the
files <TT>wotsit.gif</TT>, <TT>wotsit-hi.gif</TT>,
 <TT>wotsit-out.gif</TT>>, <TT>wotsit-mic.gif</TT> 
and <TT>wotsit.data</TT>. If all of <TT>wotsit*.gif</TT> are GIF
images sixty pixels wide and forty pixels high will consist of only
the two lines 
</P>
<PRE STYLE="margin-bottom: 0.2in">60
40</PRE><P>
<A NAME="gengui_conf"></A>(Note that GIF images are a licensed
trademark of Unisys, Inc.) Finally, the icon used to represent the
trashcan is determined by the configuration as in the next section.
</P>
<H3><A NAME="markup_parser"></A>4.3. The Markup Language Parser</H3>
<P>Once you've written down two or three annotated texts, you very
easily get bored at having to count lines and rows in order to get
your annotations in the text. In order to remedy this situation,
<B>sml_tk</B> provides a markup language, and a generic parser for
it. 
</P>
<P>The fully generic markup language parser is a functor takes as an
argument a structure describing tags. A tag is an SGML element of the
form 
</P>
<PRE STYLE="margin-bottom: 0.2in"> &lt;tagname arg1 ... argn&gt; ... &lt;/tagname&gt;</PRE><P>
This generates an annotation from the start of the tag to the end of
the tag. Tags are given by <TT>matchingTag</TT>, where the first
argument is the <TT>tagname</TT> above. The annotation is generated
by the function <TT>annotationForTag</TT>, which is passed the tag as
the first argument, and the list of arguments as the second argument.
The type <TT>widgetinfo</TT> is just a workaround to allow
<TT>annotationForTag</TT> to be passed arguments like the identity of
the widget. 
</P>
<P>The markup parser further recognizes escape sequences of the form
<TT>&amp;name;</TT>. These are given by the function <TT>escape</TT>,
which is passed the name of the escape sequence, and either returns a
string replacing the escape, or <TT>NONE</TT> in which case the
escape sequence is left as is in the text. Three escape sequences are
predefined, namely <TT>&amp;amp;</TT> for &amp;, <TT>&amp;gt;</TT>
for &gt; and <TT>&amp;lt;</TT> for &lt; (since these are needed by
any sensible markup language). 
</P>
<P>Finally, the exception <TT>AnnotationError</TT> can be raised by
the function generating to annotation to indicate an error (e.g. a
tag with not enough parameters). The exception <TT>error</TT> is
raised if there is a critical error during parsing. The parser is
actually quite good-natured, and will e.g. only print warnings (via
<TT>warning</TT>) if there are open elements which do not close (for
these, annotations up to the end of the text are generated). The only
critical errors are <TT>&lt;</TT> and <TT>&amp;</TT> not followed by
any <TT>&gt;</TT> or <TT>;</TT> respectively. 
</P>
<PRE>signature TAGS =
 sig
 type tag
 type widgetinfo

 val matchingTag : string-&gt; tag option
 val annotationForTag : tag -&gt;string list-&gt; widgetinfo-&gt;
                        (TkTypes.Mark* TkTypes.Mark)-&gt;
                        TkTypes.Annotation
 val escape : string-&gt; string option

 exception AnnotationError of string
 val warning : string-&gt; unit
 val error : string-&gt; exn
 end</PRE><P>
The markup language parser exports just one function, which takes a
text in a markup language as described by the argument, and returns
an annotated text: 
</P>
<PRE>signature SMLTK_MARKUP =
 sig
 type widgetinfo
 val getAnnText : widgetinfo-&gt; string-&gt; TkTypes.AnnoText
 end

functor SmlTkMarkup (Tags: TAGS) : SMLTK_MARKUP
 where type widgetinfo= Tags.widgetinfo</PRE><P>
The file <TT>src/toolkit/tests+examples/markup_ex.sml</TT> contains
an example of a small self-defined markup language. Moreover, the
toolkit library contains an extendible markup language, the <B>sml_tk</B>
Standard Markup Language, which provides tags to set fonts, scale
fonts, or raise and lower boxes, and in particular a rich set of
escape sequences for mathematical characters and mathematical
notations (<TT>&amp;alpha;, &amp;forall;, &amp;tensor;</TT> etc.) The
file <TT>src/toolkit/tests+examples/stdmark_ex.sml</TT> shows how to
use the standard markup language. It comes in two variations, one
which is extendible (<TT>functor StdTags</TT>) with more tags, and
one which is closed and ready to use (<TT>structure StdMarkup</TT>). 
</P>
<H3>4.4. A Common Interface for Visualizable Elements: <I>Objects</I></H3>
<P>Several higher toolkit components
require a common notion (or: format) of <I>objects </I> for their
visualization functionality - this notion is represented by the
signature <TT>OBJECT_CLASS</TT> that is part of the
input signature of the functors representing these higher Toolkit
Components. Thus, <TT>OBJECT_CLASS</TT> is fundamental for 
toolkit components like TreeList or GenGui. Morover, there is a
functor <tt>obj2tree_obj</tt>, that extends <TT>OBJECT_CLASS</TT>
to <tt>TREE-OBJECT_CLASS</TT>, where <tt>TREE-OBJECT_CLASS</TT>
is a strict signature extension of <tt>OBJECT_CLASS</tt>. The instances
of  <tt>TREE-OBJECT_CLASS</tt> all have a tree-like structure and are
suited for the representation of file-systems, proof-terms, etc. 
Once we have one notion of objects, <tt>obj2tree_obj </tt> builds
a tree-like organization with folders as nodes and input objects as
leaves. This facilitates the construction and data exchange
via uniform interfaces and common lifting facilities for
toolkit-components with respect to objects.
</P>
<P><TT>OBJECT_CLASS</TT> and its variants 
are part of the Common Infrastructure <FONT FACE="courier,
monospace">CI.</FONT> In more detail, <TT>OBJECT_CLASS</TT>
instances contain the following elements:</P>
<UL>
	<LI>a type of objects object</li>
	<LI>an ordering on object</li>
	<LI>a unique abstract name for
	each object</li>
	<LI>a (formatable) string
	representation thereof</li>
	<LI> a &quot;user-name&quot;, i.e. a string hiding the string
	representation of the name, set or reset explicitly  via
	side effects</li>
	<LI>an object type <tt>obj_type</tt> for each object</li>
	<LI>an icon for each obj-type </li>
</UL>
<P>The signature in itself reads as follows:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; signature OBJECT_CLASS =</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;
sig</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type
object</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eqtype
objtype</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type
name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* think of it as : id *)</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
ord&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: object * object -&gt; order(* based on name *)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; name_of&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : object
-&gt; name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*
think of it as : id_of *)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; string_of_name : name -&gt;&nbsp;&nbsp; Print.format -&gt;</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
rename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : string
-&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
object -&gt; unit(* side effect *)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; reset_name&nbsp;&nbsp;&nbsp;&nbsp; : object -&gt;
unit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* side effect *)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; obj_type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : object -&gt;
objtype</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
icon&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
objtype -&gt; Icons.icon</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT>
</P>
<P>More formally, these elements are specified to have the following
properties: 
</P>
<OL>
	<LI> <TT>ord</TT> is a linear ordering on names of objects</LI> 
	<LI> <TT>name_of(o)</TT> must be unique in all system states</LI>
	<LI>(* this fact is only used in tree_object_classes, <BR> more
	precisely: select_from_path,remove_at_path,update_at_path *)</LI> 
	<LI><TT>name_of(rename(s,o)) = name_of(o)&nbsp;</TT> (* rename is actually
	a relabelling *)</LI>
	<LI><TT>name_of(reset_name(s,o)) = name_of(o)</TT></LI>
	<LI><TT>obj_type(rename(s,o)) = obj_type(o)</TT> </LI>
	<LI><TT>obj_type(reset_name(s,o)) = obj_type(o)</TT></LI>
	<LI><TT>icon(rename(s,o)) = obj_type(o)</TT></LI>
	<LI><TT>icon(reset_name(s,o)) = obj_type(o)</TT></LI>
	<LI><TT>string_of_name n f</TT> should be &quot;as nice as possible&quot;.</LI>
	<LI><TT>(rename s o; string_of_name(name_of o) f) = &quot;nice s&quot;</TT></LI>
	<LI> <TT>(rename s o; reset_name o;  string_of_name o f) = <BR>
	(reset_name_node o; string_of_name_node o f)</TT> </LI>
</OL>
<P><BR><BR>
</P>
<P>In the following. we turn to the extension of
<TT>OBJECT_CLASS</tt>, namely <tt>TREE-OBJECT_CLASS</TT>.  The entity
<TT>TREE_OBJECT_CLASS</TT> is a subclass of
<TT>OBJECT_CLASS</TT>. It is enriched by <TT>FOLDER_INFO</tt>,
<tt>SUBNODE_INFO</tt> and functions that exploit (or enforce) the
tree-like structure of 
<TT>TREE_OBJECT_CLASS</TT>-elements, i.e. terms of type obj.
Additionally, they provide the concept path on folders and
path-related operations.  The auxilliary signatures
<tt>FOLDERINFO</tt> contains the information that makes abstractly the
<i>skeleton</i> or just the <i>node</i> of a folder, but not its
content. This <tt>node_info</tt> must contain the following:
</P>
<UL>
	<LI>an ordering
	<LI>an (implicit) name 
	<LI>rename and reset-name facilities 
	<LI> additional info's that may be attached directly to
	subcomponents  of a folder (i.e. positions, layout, ...)
</UL>
<P>Now, <tt>FOLDERINFO</tt> reads as follows:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; signature FOLDERINFO =</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;
sig</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;
node_info</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
type&nbsp;&nbsp; subnode_info</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp;&nbsp;&nbsp; string_of_name_node : node_info -&gt;
Print.format -&gt; string</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp;&nbsp;&nbsp; ord_node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: node_info * node_info -&gt; order</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp;&nbsp;&nbsp; rename_node&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: string -&gt; node_info -&gt; unit</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp;&nbsp;&nbsp; reset_name_node&nbsp;&nbsp;&nbsp;&nbsp; :
node_info -&gt; unit</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT> 
</P>
<P>Some properties are specified as follows:</P>
<UL>
	<LI>ord_node is a linear ordering 
	<LI> (rename_node s ni;  string_of_name_node ni f) = &quot;nice
	s&quot; 
	<LI>(rename_node s ni;  reset_name_node ni;  string_of_name_node
	ni f) = <BR> (reset_name_node ni; string_of_name_node ni f) 
</UL>
<P> The signature  <TT>TREE_OBJECT_CLASS</TT> is constructed on top:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; signature TREE_OBJECT_CLASS =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sig</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
include OBJECT_CLASS;</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
include FOLDERINFO;</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
structure Basic : OBJECT_CLASS;</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; getContent&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : object -&gt;
Basic.object * subnode_info</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; getFolder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
object -&gt; node_info * object list</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; isFolder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
object -&gt; bool</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; Content&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: Basic.object * subnode_info -&gt; object</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; Folder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: node_info * object list -&gt; object</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; isFolderType&nbsp;&nbsp;&nbsp;&nbsp; : objtype -&gt; bool</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
getContentType&nbsp;&nbsp; : objtype -&gt; Basic.objtype</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
ContentType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Basic.objtype -&gt;
objtype</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT> 
</P>
<P>Its specification contains the following conditions:</P>
<UL>
	<LI><TT>getContent(Content m) = m</TT>
	<LI><TT>getFolder(Folder m) = m</TT>
	<LI><TT>Content(getContent o) = o</TT>
	<LI><TT>Folder(getFolder o) = o</TT>
	<LI><TT>tree_objects are generated over Content and Folder</TT>
	<LI><TT>isFolder(Folder m) = true, isFolder(Content m) = false</TT>
	<LI><TT>getContentType(ContentType ot) = ot</TT>
	<LI><TT>ContentType(getContentType ot) = ot</TT> 
</UL>
<P>A variant of <TT>TREE_OBJECT_CLASS</tt> is the signature 
<TT>PTREE_OBJECT_CLASS</tt>, which extends the former by path-related
operations.</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; signature PTREE_OBJECT_CLASS =</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp; sig</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
include TREE_OBJECT_CLASS;</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type
path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= node_info list * Basic.object option</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* path and name are identical in PTREE_OBJECT_CLASS. Unfortunately,</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * this can't
be said explicitly in SML. Therefore, we establish an</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* isomorphism. *)</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
ord_path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path *
path -&gt; order</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; is_prefix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path
* path -&gt; bool</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; concat_path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path * path -&gt;
path</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
name2path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : name -&gt; path</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
path2name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : path -&gt; name</TT>
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*&nbsp;&nbsp; The
foll. opns may fail if paths do not exist or are not unique&nbsp;&nbsp;
*)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*&nbsp;&nbsp;
NOTE : this implies that node_info and obj must be unique if&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*&nbsp;&nbsp;
these operations are expected to work properly *)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val&nbsp; get_path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
object -&gt; object -&gt; path list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* get_path a b produces path</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
of sub-object b in object a *)</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
exception InconsistPath;</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
select_from_path : object list -&gt; path -&gt; object</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
remove_at_path&nbsp;&nbsp; : object list -&gt; path -&gt; object list</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* removes_at_path a&nbsp;&nbsp; produces object</TT>
<BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
from a with subobject at p removed *)</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val&nbsp;
update_at_path&nbsp;&nbsp; : object list -&gt; path -&gt; object -&gt;
object list</TT> 
</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; end</TT> 
</P>
<P>A standard method to lift instances of <TT>OBJECT_CLASS</TT>
to <TT>PTREE_OBJECT_CLASS</TT> (and thus <TT>TREE_OBJECT_CLASS</TT>) is
given by the functor <TT>obj2tree_obj</TT>, that embeds standard objects into
a tree-like data structure:</P>
<P><TT>&nbsp;&nbsp;&nbsp;&nbsp; functor obj2tree_obj (structure
N:FOLDERINFO and</TT> <BR><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
M:OBJECT_CLASS) : PTREE_OBJECT_CLASS</TT> 
</P>
<H3>4.5. A Common Interface for the Data Model:
<I>Applications</I></H3> <P>The <B>sml_tk</B>-Toolkit provides two
larger parametric components, that produce for a given
<I>application</I> a graphical user interface, slightly similar to the
model-view-controller paradigm known from object-oriented GUI
programming, where our application corresponds to the
model. Technically, these two parametric components, <tt>GenGui</tt> and
<tt>TGenGui</tt>, are implemented as functors that map applications
to widgets that contain the GUI for this application. Applications are
part of the Common Infrastructure CI.</P> 
<P>In the following, we represent a family of <I>application
signatures </I> <TT>NP0_APPL_SIG, 
NP_APPL_SIG</TT> and <TT>APPL_SIG</TT> that represent the interface into
which a given application must be wrapped in order to be accomodated
for this functor. 
</P>
<P>An application essentially contains:</P>
<UL>
	<LI>the class of objects an application is working with (given by <tt>OBJECT_CLASS</tt>)
	<LI>additional information for objects used for a refined handling in a
        GUI - <BR>an object can have a <I>mode </I>(for advanced drag&amp;drop
        interaction) or belong to<BR>the special group of <I>construction </I>objects
	<LI>a table of actions manipulating objects (called mon_ops for historical
	reasons)
	<LI>a table of drag-drop actions associated with objects (calles bin_ops
	for historical reasons
	<LI>a clibboard for exchanging objects between parts of a gui via
	drag-drop
	<LI>a complete subwidet called <I>construction area </I>where
	application defined &quot;small grain&quot; <BR>modifications with
	construction objects can be handled
	<LI>a gui-state for persistent tool implementations.
</UL>
<P>In more detail, the discussed signatures look as follows:</P>
<P><TT>ignature NP0_APPL_SIG =</TT><BR>
       <TT><TT>&nbsp; sig</TT></TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; include OBJECT_CLASS</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* New objects are objects
together with an annotation where</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * they should appear.&nbsp;
This is a coordinate followed by an Anchor</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * which gives the direction
in which GenGUI tries to place the</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * object if another object
is in the way.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * new_object will correspond
directly to Contents in TreeObjects.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; type new_object = object *
(SmlTk.Coord* SmlTk.AnchorKind)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* Now comes the
GenGUI-specific OBJECT_CLASS extensions:</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Typing, modes,
is_constructed, outline. *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; (* Typing *)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; val objlist_type : object
list -&gt; objtype Option.option</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; val is_constructed :
objtype-&gt; bool</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* objects of this type are construction objects *)</TT> <TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT><BR>&nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* &quot;Modes&quot; are
states for objects. They are changed with the object's pop-up</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * menu, which displays the
mode by the mode_name given below.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * Every object's mode can be
set within the range given by its type</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * (function modes below) by
set_mode.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * Every object's mode can be
set within the range given by its type (function</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * modes below) by set_mode.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; eqtype mode</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; val mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: objtype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; mode&nbsp;&nbsp;
(* New ! mode is attached to objtype</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for structuring reasons . . . *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val modes&nbsp;&nbsp;&nbsp;&nbsp;
: objtype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -&gt; mode list</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val mode_name : mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&gt; string</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val set_mode&nbsp; : object * mode
-&gt; unit</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* These objects are
displayed with an &quot;outline&quot; icon, to indicate</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * some out-of-date
condition. Note that they can still receive</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * drag-and-drop operations.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val outline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: object-&gt; bool</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (*</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * Nullary objects are
constants, or in other words, objects</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * existiting a priori.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * The init function returns
a list of all these objects; it will</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * only be called once, on
startup.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val init&nbsp;&nbsp; : unit -&gt;
new_object list</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* Unary operations *)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* standard actions, called
ops for historic reasons *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val std_ops&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: objtype-&gt; ((object -&gt; unit) * string) list</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* better signature ? *)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; val create_actions: (({pos :
SmlTk.Coord, tag : string} -&gt; unit)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* string) list</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val label_action&nbsp; : {obj :
object,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cc : string -&gt; unit}-&gt; unit</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val delete&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: object -&gt; unit</TT> <BR>&nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* further object type
specific operations: for a type t, monOps t</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * is a list of pairs (f, s),
where f is a unary operation, and s</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * is a string, the name
under which it appears in the pop-up</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * menu. f has the
functionality</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp;&nbsp;&nbsp;&nbsp;
object* SmlTk.Coord-&gt; (newObject-&gt; unit)-&gt; unit;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * where the first argument
is the object itself, together with its present</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * location, and the second
argument is a continuation you can use</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * to create new objects.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val mon_ops : objtype -&gt;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((object * SmlTk.Coord -&gt;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(new_object -&gt;&nbsp; unit) -&gt; unit) * string) list</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (*</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * binary operations</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * aka.the
drag&amp;drop-action-table</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val bin_ops :&nbsp; objtype *
objtype -&gt; (object * SmlTk.Coord *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
object list *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(new_object-&gt; unit) -&gt; unit)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Option.option</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* --- Substructures
-------------------------------------------------- *)</TT> &nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp;&nbsp; (* The clipboard will
allow the exchange of items between</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * the drag&amp;drop
area and other application-specific</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * widgets-- eg. a
chooser.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * It gets passed
closures of objects, so we create</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * an object only if it
is really taken out of the clipboard</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp;&nbsp; type objectlist= unit-&gt;
object list</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; structure CB : CLIPBOARD</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; sharing type CB.obj =
objectlist</TT> <BR>&nbsp; <TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp; (* --- Configuration -- see above --- *)</TT>
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; structure Conf : GENGUI_CONF</TT>
<BR>&nbsp; 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>end;</TT> <BR><BR>This signature is enriched by
a concept of object locking in signature  <TT>NP_APPL_SIG:</TT></P>
<P><TT><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>signature NP_APPL_SIG =</TT></TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN><TT>&nbsp; sig</TT></TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; include NP0_APPL_SIG</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; val object_action&nbsp;&nbsp;
: {win : SmlTk.WinId,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
obj : object,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
replace_object_action : object -&gt; unit,</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
outline_object_action : unit -&gt; unit}</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
-&gt; unit</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; val is_locked_object: object
-&gt; bool (* locking manipulations -</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* e.g. opened construction objects *)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>end;</TT> 
</P>
<P>Finally, the concepts for the
construction area and a GUI state (plus initialization operations)
are added:</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>signature APPL_SIG =</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp; sig</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; include NP0_APPL_SIG</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* --- The Construction Area
----------------------------------------- *)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; type ca</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* This data type represents
the Construction Area's</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * state. It might eg.
probably contain the area's</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * widget's widget id.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* This should be the
respective row of the drag&amp;drop table in</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * binaryOps above. Has to be
here explicitly, since it will change</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * the whole area rather than
just the object. Further, objects may</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * behave differently while
being open.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val&nbsp; area_ops&nbsp; :
objtype-&gt; ca-&gt; object list-&gt; unit</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp;&nbsp;&nbsp; (* open an object to be
worked on the construction area</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * The old object is deleted
from the manipulation area.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * One (or even more?) new
objects may appear on the notepad</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * when the construction
finishes, they are introduced with</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * the second argument.</TT>
<BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * The result is a tuple,
consisting of a data structure</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * ws as above, a list of
widgets representing the</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * area on the screen and an
init function to be called after</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * the widget has been placed
and that would not be necessary</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; * if we could instantiate
text widgets properly.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; *)</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val area_open&nbsp; : SmlTk.WinId*
object* (object -&gt; unit) -&gt;</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(ca* SmlTk.Widget list* (unit-&gt; unit))</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp; val area_init&nbsp; : unit-&gt;
unit</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* initializations that need to be done only once.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* !!! Caution, this is called when the area isn't open.</TT> <BR><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*)</TT> 
</P>
<P><TT><TT><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal">
  </SPAN></SPAN></TT>&nbsp; end</TT> 
</P>
<H3>4.6. Utility Windows</H3>
<P>The module <TT>UW</TT> offers a variety of often used windows
for user confirmation, error or warning messages, or user input.
Conceptually, there are two different types of input dialogues: <I>modal</I>
and <I>non-modal</I>. With modal windows, the whole system should
only proceed once the input is completed; with non-modal windows, the
input can be mixed arbitrarily with other inputs. Non-modal windows
may remain open and communicate via a global state. Nearly all of the
windows exported from <TT>util_win</TT> are non-modal in the above
sense, except for <TT>enterText</TT> and <TT>enterLine</TT>. 
</P>
<P>In detail, the module <TT>util_win</TT> exports the following
functions: 
</P>
<h4>Errors and warnings:</h4>
The simple, non-modal form of these is: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> val error : string -&gt; unit</FONT>
<FONT SIZE=3> val warning : string -&gt; unit</FONT></PRE><P>
Brings up a window with an error or warning messages as given by the
first argument, and once the OK button is clicked. There is no
semantic difference between an error and a warning except for the
icon used. 
<P>For modal error or warning windows, use the following: 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>val error_cc : string* (unit-&gt; unit)-&gt; unit</FONT>
<FONT SIZE=3> val warning_cc : string* (unit-&gt; unit)-&gt; unit</FONT></PRE><P>
The argument should be the continuation, i.e. the function to be
called after the <TT>Continue</TT> button has been clicked. Both of
these functions return once they opened the window, so for modal
behaviour you'll have to pass the continuation: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> let val go_on = fn x=&gt; (print(&quot;The close button has been clicked.\n&quot;);</FONT>
<FONT SIZE=3>                         testw x)</FONT>
<FONT SIZE=3> in UW.error_cc(&quot;An error has occured.&quot;, go_on);</FONT>
<FONT SIZE=3> print &quot;The window has just been opened.\n&quot;</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
<IMG SRC="images/error.gif" NAME="Grafik5" ALT="[An Error Window]" ALIGN=MIDDLE WIDTH=320 HEIGHT=170 BORDER=0><IMG SRC="images/warning.gif" NAME="Grafik6" ALT="[A Warning Window]" ALIGN=MIDDLE WIDTH=300 HEIGHT=138 BORDER=0>
<BR>&nbsp; <BR>&nbsp; 
</P>
<h4>Confirmation</h4>
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"><FONT SIZE=3> val confirm : string* (unit-&gt; unit)-&gt;unit</FONT></PRE><P>
Brings up a window with the given text. If the user clicks the OK
button, the continuation is called, otherwise the call evaluates to
nothing. The window looks like this: 
</P>
<UL>
	<P><IMG SRC="images/confirm.gif" NAME="Grafik7" ALT="[AConfirmation Window]" ALIGN=BOTTOM WIDTH=360 HEIGHT=160 BORDER=0>
		</P>
</UL>
<P>The icon appearing with the confirmation window is the same as
appearing in warning windows (but this can be changed - see below). 
</P>
<h4>Information windows.</h4>
<P>Information windows display informative messages to the user. They
come in two variations, a simple non-modal one which stays open until
it is dismissed, and a modal one, which returns a function which when
called closes the window (ensuring it stays open at least ten
seconds). 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> val info : string-&gt; unit</FONT>
<FONT SIZE=3> val info_cc : string-&gt; (unit-&gt; unit)</FONT></PRE><P>
Both open a window like the following, except the modal version lacks
a close button: 
</P><UL>
<P><IMG SRC="images/info.gif" NAME="Grafik7" ALT="[An information window]" ALIGN=BOTTOM WIDTH=300 HEIGHT=188 BORDER=0>
</P></UL>
<h4>Displaying texts.</h4>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"><FONT SIZE=3> val display: {title: string, width: int, height: int,</FONT>
<FONT SIZE=3> text: SmlTk.AnnoText, cc: SmlTk.WidId-&gt; unit}-&gt; unit</FONT>

<FONT SIZE=3> val display_id: {winId: SmlTk.WinId, widId: SmlTk.WidId, title: string,</FONT>
<FONT SIZE=3> width: int, height: int, text: SmlTk.AnnoText}-&gt; unit</FONT></PRE><P>
These functions open up a window and display an annotated text in a
dedicated window with a close button at the bottom left corner. Their
difference is the way in which the identity of the text widget is
handled: the first variant creates a text widget from scratch, and
passes the widget id to the continuation <TT>cc</TT>, the other takes
a window and widget id as argument and builds a text widget in a
window of that parish. 
</P>
<h4>Entering Text.</h4>
<PRE >
 val enterText : {title : string, prompt : string, default : string,
 width : int, height : int, cc : string-&gt; unit} -&gt; unit 
 val enterLine : {title : string, prompt : string, default : string,
 width : int, cc : string-&gt; unit } -&gt; unit
</PRE>
<BR><BR>These functions invite the user to enter some text, either a single
line of it (<TT>enterLine</TT>) in a single entry widget, or a larger oeuvre
in a text widget of many lines (<TT>enterText</TT>). Both are given a
<TT>default</TT> string to fill the text or entry widget with, a window
<TT>title</TT>, a <TT>prompt</TT> string diplayed in front of or above the
entry or text widget, and a continuation <TT>cc</TT> which is passed the text
once the entry has finished. Both functions bring up a window with an ok and a
cancel button. but entry in an <TT>enterLine</TT> widget is finished by
pressing return.

<H4>Configuring <TT>util_win</TT></H4>
<P>If you want different fonts, icons or layout, all can be easily
rearranged by changing the configurations of the utility windows,
which are the first couple of lines in <TT>src/toolkit/util_win.sml</TT>.
<BR>&nbsp; 
</P>

<H3 STYLE="margin-top: 0in">4.7. Numeric Choosers</H3>
<P>Simple numeric choosers, an entry for integer values as in the
following dialog (taken from the tabs example in
<TT>src/toolkit/tests+examples/tabs_ex.sml</TT>):
</P> 

<UL>
<P><IMG SRC="images/numeric_choosers.gif" NAME="Grafik12" ALIGN=BOTTOM WIDTH=280 HEIGHT=70 BORDER=0> </P></UL>
<br>
<P>The structure <TT>NumericChooser</TT>
has the following export signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature NUMERIC_CHOOSER_SIG =</FONT>
<FONT SIZE=3> sig</FONT>
<FONT SIZE=3> val numeric_chooser : {initial_value : int,</FONT>
<FONT SIZE=3> min : int option,</FONT>
<FONT SIZE=3> max : int option,</FONT>
<FONT SIZE=3> increment : int,</FONT>
<FONT SIZE=3> width : int,</FONT>
<FONT SIZE=3> orientation : SmlTk.Orientation,</FONT>
<FONT SIZE=3> selection_notifier : int -&gt; unit} -&gt;</FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<FONT SIZE=3>chooser : SmlTk.Widget,</FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE=3> set_value : int -&gt; unit,</FONT>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<FONT SIZE=3> read_value : unit -&gt; int}</FONT>
<FONT SIZE=3> end</FONT></PRE></P>
The function <TT>numeric_chooser</TT> needs the following data to
create a numeric chooser: the initial value of the chooser, an 
optional minimum and maximum value, a value to add/subtract when a
button is pressed, the number of columns of the label, in which the
value is displayed, the orientation of the chooser (<FONT FACE="courier, monospace">SmlTk.Vertical</FONT>
or <FONT FACE="courier, monospace">SmlTk.Horizontal</FONT>) and a
function to be called when the value changes.  It returns a frame widget
containing the numeric chooser, a function for external setting of
the value and a function that returns the current value of the
chooser. 
</P>
<H3>4.8. The Filer</H3>
<P>The functor <TT>Filer</TT> offers a generic file browser, allowing
the user to browse the file system in the usual manner, and even
search for regular expressions: 
</P>
<P><IMG SRC="images/filer.gif" NAME="Grafik9" ALIGN=BOTTOM WIDTH=655 HEIGHT=541 BORDER=0>
</P>
<P>The <FONT FACE="courier, monospace">Filer</FONT> functor has the
following argument signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>sig</FONT>
<FONT SIZE=3> val icons_path : unit -&gt; string</FONT></PRE><P>
The directory containing the icons to display for the filetypes
specified in the list below. 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>val icons_size : int * int</FONT></PRE><P>
The maximum width and height of these icons, needed to calculate the
width and height of the file entries. 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>val root : unit -&gt; string option</FONT></PRE><P>
An optional root directory in the browsed filesystem (if there is no
root directory specified, the whole filesystem is browsed). 
</P>
<PRE STYLE="margin-bottom: 0.2in"> <FONT SIZE=3>val default_pattern : string option</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The displayed files are
filtered using the regular expression matcher contributed by Ryan
Stansifer &lt;<A HREF="mailto:ryan@cs.unt.edu">ryan@cs.unt.edu</A>&gt;
(which can be found in </FONT><FONT FACE="courier, monospace">src/toolkit/regExp</FONT><FONT FACE="times, serif">).
Here you can specify a default pattern, which still can be changed by
the user, but which is reapplied for every new entered directory.</FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>structure CB : CLIPBOARD_W</FONT></PRE><P>
The clipboard instantiation (see <A HREF="#clipboard">Sect. 4.5 below</A>
for further informations on the clipboard). 
</P>
<PRE>
val filetypes : {ext : string list
                 display :{comment : string,
                           icon : string,
                 preview : ({dir : string,
                             file : string} -&gt; unit) option,
                 file_to_obj : ({dir : string,
                                 file : string} -&gt; CB.obj)
                               option} option} list</PRE><P>
The list of known filetypes. A file is associated with a filetype by
the extension. The extensions matching a filetype are given in a
<FONT SIZE=2><FONT FACE="courier, monospace">string list</FONT></FONT>.
You can also specify a default filetype (using the empty string <FONT FACE="courier, monospace">&quot;&quot;</FONT>
in the extensions list), which is applied when no other filetype is
matched. If no default filetype is specified, unmatched files are
displayed as &raquo;Unknown filetype&laquo; with a system icon. The
file type determines the icon used to display the file, how to
preview a file with the middle mouse button, and how to import it
into other <B>smlt_tk</B> components. 
</P>
<P>The <FONT FACE="courier, monospace">display</FONT> parameter is an
option, because you might not want to display all filetypes. If it is
set to <FONT FACE="courier, monospace">NONE</FONT>, files of this
type will not be displayed. If a filetype should be displayed, you
need to specify at least a comment to display with the files, such as
&raquo;GIF image&laquo; of &raquo;ML source&laquo;, and an icon (of
the maximum size above). Optionally there is also a preview function
to be called with the file (see also the filer example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/filer_ex.sml</FONT>).
The optional <FONT FACE="courier, monospace">file_to_obj</FONT>
function is part of the clipboard instantiation and returns a
representation of the dragged file in the clipboard object type. It
only needs to be specified if you want to provide drag and drop
functionality for this filetype. 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"><FONT SIZE=3> structure Conf : FILER_CONFIG</FONT></PRE><P>
In the <FONT FACE="courier, monospace">Conf</FONT> structure further
configuration options concerning the look and feel of the filer are
offered. There is also a structure <FONT FACE="courier, monospace">FilerDefaultConfig</FONT>
(in <FONT FACE="courier, monospace">src/toolkit/filer_default_config.sml</FONT>),
which you can use if you do not want to configure the filer from
scratch. 
</P>
<PRE STYLE="margin-bottom: 0.2in">end</PRE><P>
The structure <FONT FACE="courier, monospace">Conf</FONT> has to
match the following signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature FILER_CONFIG =</FONT>
<FONT SIZE=3> sig</FONT>
<FONT SIZE=3> val title : string option</FONT></PRE><P>
The title of the file selection window. If no title is specified, it
will be &raquo;File selection&laquo;. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>val font : SmlTk.Font</FONT>
<FONT SIZE=3> val font_height : int</FONT></PRE><P>
The font to use in the file selection dialog, its height in pixels is
needed to calculate the height of a single lines in the files- and
folders-boxes. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>val foldersbox_width : int</FONT>
<FONT SIZE=3> val filesbox_width : int</FONT>
<FONT SIZE=3> val filesbox_numcols : int</FONT>
<FONT SIZE=3> val boxes_height : int</FONT></PRE><P>
The size of the boxes (in pixels), in which the files and folders are
displayed, the number of columns of icons in the files box, and the
height. Both boxes have the same height. The width of the filesbox
must be at least <TT>filesbox_numcols</TT> times the width of a label
containing <FONT FACE="courier, monospace">filenames_cut</FONT>
characters (see below) in the specified font, otherwise the file
entries might cross the right border of the visible part of the
filesbox canvas (because <B>sml_tk</B> cannot really calculate the
size of any components drawn onto a canvas-Widget). 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>val foldernames_cut : int</FONT>
<FONT SIZE=3> val filenames_cut : int</FONT></PRE><P>
Here you can specify the maximum length of the displayed names of the
files and folders. 
</P>
<PRE STYLE="margin-left: 0.79in"> val icon_font : SmlTk.Font
 val icon_font_height : int</PRE><P>
The user can choose between detailed mode, which means that files are
displayed with comments and the date of last modification, and
non-detailed mode, where only the icon and filename is displayed in
&raquo;icon style&laquo;. In this case, you might want to use a
smaller font, which you can specify here, and of course you need to
give the maximum height of this font here as well. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>val preferences : {sort_names : bool,</FONT>
<FONT SIZE=3> sort_types : bool,</FONT>
<FONT SIZE=3> show_hidden_files : bool,</FONT>
<FONT SIZE=3> hide_icons : bool,</FONT>
<FONT SIZE=3> hide_details : bool}</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
These are the user configurable settings, when the filer is first
opened. As mentioned above, the files can be displayed in detailed or
non-detailed mode, but the user can also choose if and how the files
should be sorted, if he wants to see hidden files and if icons should
be displayed. <BR>The filer can be run in two modes: stand-alone,
where it runs as the main <B>sml_tk</B> window, and returns the
directory and file name of a selected file, and as a subwindow, where
the filer communicates with other components via drag&amp;drop. Thus,
we have the following export signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature FILER_SIG =</FONT>
<FONT SIZE=3> sig</FONT>

<FONT SIZE=3> (* critical errors -- e.g. can't open root directory *)</FONT>
<FONT SIZE=3> exception Error of string</FONT>

<FONT SIZE=3> (* stand alone version *)</FONT>
<FONT SIZE=3> val stand_alone : unit -&gt; (string option * string option) option</FONT>

<FONT SIZE=3> (* system versions *)</FONT>
<FONT SIZE=3> val file_select : ((string option * string option) option -&gt; unit) -&gt; unit</FONT>
<FONT SIZE=3> val enter_file : unit -&gt; unit</FONT></PRE><P>
<TT>stand_alone</TT>starts its own wish using <FONT FACE="courier, monospace">startTcl</FONT>
and therefore should not be used in the context of a running
<B>sml_tk</B>-based application. Its main use is probably to debug
filer configurations. The <TT>file_select</TT> function needs a
continuation function to be called with the the directory and file
name of a selected file, both as an option because there might be
none. The normal way to start the filer is the <TT>enter_file</TT>
function. It does not return a value, since selected files will be
exchanged via the clipboard (see below). 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>(* set preferences *)</FONT>
<FONT SIZE=3> val set :{sort_names : bool option,</FONT>
<FONT SIZE=3> sort_types : bool option,</FONT>
<FONT SIZE=3> show_hidden_files : bool option,</FONT>
<FONT SIZE=3> hide_icons : bool option,</FONT>
<FONT SIZE=3> hide_details : bool option} -&gt; unit</FONT>
<FONT SIZE=3>end</FONT></PRE><P>
The <FONT FACE="courier, monospace">set</FONT> function can be used
to set the user configurable options. It should only be used when the
file selection window is not open. <BR>There is also a partial
instantiation of the filer without clipboard support, the functor
<FONT FACE="courier, monospace">SimpleFiler</FONT>, which has the
following argument signature: 
</P>
<PRE STYLE="margin-left: 0.79in">f<FONT SIZE=3>unctor SimpleFiler(structure Options :</FONT>
<FONT SIZE=3> sig</FONT>
<FONT SIZE=3> val icons_path : unit -&gt; string</FONT>
<FONT SIZE=3> val icons_size : int * int</FONT>
<FONT SIZE=3> val root : unit -&gt; string option</FONT>
<FONT SIZE=3> val default_pattern : string option</FONT>

<FONT SIZE=3> val filetypes : {ext : string list,</FONT>
<FONT SIZE=3> display : {comment : string,</FONT>
<FONT SIZE=3> icon : string,</FONT>
<FONT SIZE=3> preview : ({dir : string,</FONT>
<FONT SIZE=3> file : string} -&gt; unit) option,</FONT>
<FONT SIZE=3> (* instantiate with NONE ! *) file_to_obj : ({dir : string,</FONT>
<FONT SIZE=3> file : string} -&gt; DummyCB.obj) option} option} list</FONT>

<FONT SIZE=3> structure Conf : FILER_CONFIG</FONT>
<FONT SIZE=3> end) : FILER_SIG</FONT></PRE><P>
As there is no clipboard support, you don't need to specify
<FONT FACE="courier, monospace">file_to_obj</FONT> functions in the
filetypes list. 
</P>
<H3>4.9. Displaying and Browsing Tree-like Structures: Tree Lists</H3>
<P>Tree Lists are used to edit, browse and select in tree-like
objects. These tree-like objects are represented by <FONT FACE="courier, monospace">PTREE_OBJECT</FONT>,
a data structure that is part of the Common Infrastructure <FONT
FACE="courier, monospace">CI</FONT> which is also used by other GUI
components. Consequently, 
<FONT FACE="courier, monospace">PTREE_OBJECTS</FONT> can be
exchanged with these components via the clipboard. A
tree list can look like in the following screenshot (taken
from the example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/tree_list_ex.sml</FONT>):
</P>
<P><IMG SRC="images/treelist.gif" NAME="Graphic3" ALIGN=BOTTOM WIDTH=400 HEIGHT=360 BORDER=0>
</P>
<P>TreeList is a functor that maps objects of  <FONT FACE="courier, monospace">PTREE_OBJECT_CLASS</FONT>
(enriched by additional information) to a widget together with
operations maniputating its state. The input signatures are in
detail:</P>
<P STYLE="margin-left: 0.79in"><BR> <FONT FACE="courier, monospace">signature
TL_ACTION = <BR>&nbsp; sig <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;
object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (* SML-necessity since no
HO-functors *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eqtype node_info&nbsp;&nbsp;&nbsp;
(* SML-necessity since no HO-functors *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
type&nbsp;&nbsp; subnode_info (* SML-necessity since no HO-functors
*) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp; path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* SML-necessity since no HO-functors *) </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val content_label_action : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{path:path, was: string, cc: string -&gt; unit} -&gt; unit <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* fired whenever a content label is activated. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* Should be a modal action. *) </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val focus_change_notifier : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{changed_at:path list} -&gt; unit <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* fired whenever a folder label or a folder icon is modified;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
should be used if TreeList is nonmodally coupled over <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* gui_state with a notepad. *) </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val objtree_change_notifier : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{changed_at: path} -&gt; unit <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* fired whenever the tree-structure (gui_state) has been modified -
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
e.g. as a consequence of an internal drag-drop. <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* Used for rehresh`s of other views. *) </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val open_close_notifier : <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{is_open:bool,changed_at:path list} -&gt; unit <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* fired whenever a folder label or a folder icon is opened;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
can be used if internal tree is incrementally . *) </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val error_action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: string -&gt; unit <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* fired whenever illegal drag-drop-operations are attempted.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *
Should be a modal action. *) <BR>&nbsp; end </FONT>
</P>
<P><FONT FACE="times, serif">Note that open_close_notifier can be
used to generate this part of a subtree that is not already
displayed; by this means, large trees can be displayed by
incrementally inserting additional parts of the tree-state whenever
this part is actually needed in the display.  For technical reasons,
the following wrapper signature brings all elements together that are
needed for the TreeList functor:</FONT></P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">signature
JOIN = (* only there fore stupid SML-reasons *) <BR>  sig <BR>&nbsp;&nbsp;&nbsp;&nbsp;
structure&nbsp; M&nbsp; : PTREE_OBJECT_CLASS; <BR> &nbsp;&nbsp;&nbsp;
structure&nbsp; A&nbsp; : TL_ACTION; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
structure&nbsp; CB : CLIPBOARD; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type A.object&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= M.object; <BR>&nbsp;&nbsp;&nbsp;&nbsp; type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
objlist = unit -&gt; M.object list;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* there it is, the stupid reason *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type CB.obj&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= objlist; <BR>&nbsp;&nbsp;&nbsp;&nbsp; sharing&nbsp;&nbsp;&nbsp;
type A.node_info&nbsp;&nbsp;&nbsp; = M.node_info; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type A.subnode_info = M.subnode_info; <BR>&nbsp;&nbsp;&nbsp;&nbsp;
sharing&nbsp;&nbsp;&nbsp; type A.path&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= M.path <BR>&nbsp; end </FONT>
</P>
<P><FONT FACE="times, serif">On top of this definition, we have the
functor TreeList that generates our gui-component:</FONT></P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">functor
TreeList (structure&nbsp; S : JOIN) : <BR> sig <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
datatype scale&nbsp;&nbsp; = micro | mini | demo <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
type config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = {hight&nbsp;&nbsp;&nbsp;&nbsp;
: int ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* default 300 *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
width&nbsp;&nbsp;&nbsp;&nbsp; : int ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* default 400 *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
scrolltype: SmlTk.ScrollType ref,(* default NoneScb*)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
no_icons&nbsp; : bool ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* no icons used;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* default false *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std_icons : bool ref,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* use icons speci-
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* fied in M or use
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* std-icons;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* default true *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
scale_factor: scale ref&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(* scales display,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
* default micro *) <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val Config&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
: config </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val create_canvas: S.M.object list -&gt; SmlTk.Widget </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val upd_guistate : S.M.path -&gt; S.M.object list -&gt; unit <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val get_guistate : unit -&gt; S.M.object list <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val refresh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : S.M.path -&gt; unit
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; val refresh_label: unit -&gt;
unit </FONT>
</P>
<P STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val get_selected : unit -&gt; S.M.object list <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
val set_selected : S.M.path list -&gt; unit <BR>&nbsp;&nbsp; end</FONT></P>
<H3 STYLE="margin-top: 0in">4.10. Lazy Tree Lists</H3>
<P>There is a slighly older version of the TreeList-Component
described in the previous section, called Lazy Tree Lists. It has
even in some parts a slightly better implementation, but is not
integrated into the common infrastructure (CI). It also provides a
simple history to navigate within the browsed data. You have to
instantiate <FONT FACE="courier, monospace">LazyTree</FONT> with an
object type and some functionality on it. Most prominently, the lazy
tree lists are used in the filer, whence the following screenshot has
been taken: 
</P>
<P><IMG SRC="images/lazy_tree_lists.gif" NAME="Grafik14" BORDER=0><BR>&nbsp;
<BR>&nbsp; 
</P>
<P>The functor <FONT FACE="courier,
monospace">LazyTree</FONT> has the following argument signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>functor LazyTree(structure Obj : LAZY_TREE_OBJECTS)</FONT>

<FONT SIZE=3>signature LAZY_TREE_OBJECTS =</FONT>
<FONT SIZE=3> sig</FONT>
<FONT SIZE=3> type obj</FONT>

<FONT SIZE=3> val children : obj -&gt; obj list</FONT>
<FONT SIZE=3> val is_leaf : obj -&gt; bool</FONT>
<FONT SIZE=3> val sel_name : obj -&gt; string</FONT>
<FONT SIZE=3> val icon : obj -&gt; SmlTk.IconKind</FONT>
<FONT SIZE=3> val selected_icon : obj -&gt; SmlTk.IconKind</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
The type <TT>obj</TT> is a representation of the objects to display
in the tree list. The other functions are selectors for the needed
information to build the tree: A function to get the children of a
single object, a function that must be <TT>true</TT> for leaf objects
of the displayed tree, a function to get the name of a single object
and functions that return the icons to display for a single selected
and non-selected object. <BR>The export signature is: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace"><FONT SIZE=3>functor LazyTree(structure Obj : LAZY_TREE_OBJECTS) :</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> sig</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type obj = Obj.obj</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> exception Error of string</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> datatype history_state = hist_start | hist_middle | hist_end | hist_empty</FONT></FONT></PRE><P>
The object type, an exception to be raised when errors occur and the
return type of the function <TT>position</TT> below, that returns the
position within the history. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>val tree_list :</FONT>
<FONT SIZE=3> {width : int,</FONT>
<FONT SIZE=3> height : int,</FONT>
<FONT SIZE=3> font : SmlTk.Font,</FONT>
<FONT SIZE=3> selection_notifier : obj option -&gt; unit} -&gt;</FONT></PRE><P>
The tree list configuration options: The size in pixels of canvas
widget containing the tree list, the font to use, a function to be
called with the selected object (when the selection changes; the
selected object is given as an option, because the selection can also
change to none, e.g. when the parent node of the selected object is
closed). 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>{canvas : obj -&gt; SmlTk.Widget,</FONT>
<FONT SIZE=3> selection : unit -&gt; obj option,</FONT>
<FONT SIZE=3> up : unit -&gt; unit,</FONT>
<FONT SIZE=3> position : unit -&gt; history_state,</FONT>
<FONT SIZE=3> back : unit -&gt; unit,</FONT>
<FONT SIZE=3> forward : unit -&gt; unit}</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
<FONT FACE="courier, monospace"><FONT FACE="times, serif">The
function </FONT><TT><FONT FACE="times, serif">tree_list</FONT></TT><FONT FACE="times, serif">
returns the canvas widget containing the tree list, a function that
return the selected object as an option (there might be none), a
function to change the selection to the parent node, a function that
returns whether the history is empty, at the beginning, the end or
somewhere in the middle (which might be needed if you want to
activate/deactive buttons associated with the history functionality
in the user interface; see also datatype history_state above), a and
functions that make the tree list go backwards and forward in the
history. </FONT></FONT>
</P>
<H3>4.11. The drag&amp;drop package</H3>
<P>The drag&amp;drop package is the lower layer of the generic
interface package. It provides a canvas on which items are displayed,
which can be ``grabbed'' with the mouse (by moving the cursor on them
and pressing the right mouse button) and ``dropped'' (moving the
cursor to another place on the canvas and releasing the right mouse
button). By dropping objects onto each other, specific operations can
be triggered. 
</P>
<P>Like GenGUI, the package is generic over the items in question: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>functor DragAndDrop(DDitems: DDITEMS) :</FONT>
<FONT SIZE=3> sig</FONT>
<FONT SIZE=3> include DRAG_DROP_SIG</FONT>
<FONT SIZE=3> sharing type item = DDitems.item</FONT>
<FONT SIZE=3> end</FONT></PRE><P>
with the following export signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature DRAG_DROP_SIG =</FONT>
<FONT SIZE=3>sig</FONT>
<FONT SIZE=3> type item;</FONT>
<FONT SIZE=3> type DDCanvas;</FONT>

<FONT SIZE=3> exception DragAndDrop of string;</FONT>

<FONT SIZE=3> val init : TkTypes.WidId-&gt; DDCanvas;</FONT>
<FONT SIZE=3> val place : DDCanvas-&gt; item -&gt; unit;</FONT>
<FONT SIZE=3> val delete : DDCanvas-&gt; item -&gt; unit;</FONT>

<FONT SIZE=3> val canvasBindings : TkTypes.WidId -&gt; TkTypes.Binding list;</FONT>
<FONT SIZE=3>end</FONT></PRE><P>
Technically, the drag&amp;drop package enriches the items on a canvas
to handle drag&amp;drop style manipulation. One creates a canvas
widget, and passes its widget ID to the function <TT>init</TT>. The
result is a <I>drag&amp;drop</I>-canvas, on which one can place items
with the function <TT>place</TT> and delete objects by the function
<TT>delete</TT>. These items are described by the signatures <TT>DDITEMS</TT>:
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature DDITEMS =</FONT>
<FONT SIZE=3>sig</FONT>
<FONT SIZE=3> type item</FONT>

<FONT SIZE=3> val selItemId : item-&gt; TkTypes.CItemId</FONT>
<FONT SIZE=3> val selDropZone : item-&gt; Coord.Rect</FONT>
<FONT SIZE=3> val isImmobile : item-&gt; bool</FONT>

<FONT SIZE=3> val grab : item-&gt; unit</FONT>
<FONT SIZE=3> val release : item-&gt; unit</FONT>

<FONT SIZE=3> val enter : item -&gt; item list -&gt; bool</FONT>
<FONT SIZE=3> val leave : item -&gt; unit</FONT>
<FONT SIZE=3> val drop : item -&gt; item list -&gt; bool</FONT>

<FONT SIZE=3> structure CB : sig include CLIPBOARD_W</FONT>
<FONT SIZE=3> sharing type obj= item</FONT>
<FONT SIZE=3> end</FONT>
<FONT SIZE=3>end</FONT></PRE><P>
The function <TT>selCItemId</TT> returns the Id of the underlying
canvas item. Every item has a <I>drop zone</I> associated with it.
This is the area, relative to the canvas item's upper left corner, in
which the item is susceptible to drag&amp;drop operations. (It is
left to the structure providing the drag&amp;drop items to ensure
that the drop zone does not extend beyond the underlying item.) 
</P>
<P>Items can be selected by clicking them with the middle mouse
button (the ``select'' button). Selected items are highlighted;
selection allows cut, copy &amp; paste operations, and in particular
dragging multiple objects. 
</P>
<P>If the cursor is moved over an item <TT>i</TT>, and the left mouse
button (called the grab button hereafter) is pressed, the item (along
with other previously selected items) is ``grabbed'', if the function
<TT>isImmobile i</TT> returns <TT>false</TT> (otherwise, nothing
happens). The function <TT>grab i</TT> is called, so the item can
e.g. change its graphical representation to indicate this fact. The
object may either stay where it is, and the cursor may change shape
to indicate the user is currently moving an item, or the whole object
may be moved about along with the cursor, depending on the
implementation of drag&amp;drop, but the item structure should not
make any presumptions about this. 
</P>
<P>If the cursor enters the drop zone of an item <TT>i</TT> while
dragging another objects <TT>[j_1,...,j_n]</TT>, the function <TT>enter
i [j_1,...,j_n]</TT> is called. If it returns <TT>true</TT>, the
entered object <TT>i</TT> is supposed to be accepting a drop of the
objects <TT>j_1,...,j_n</TT>. It may (and should) change its visual
representation to signal this fact. If the cursor is then released
without having left the drop zone, a drop operation is performed by
calling the function <TT>drop i [j_1, ..., j_n]</TT>. If the result
is <TT>false</TT>, the drop is said to be &quot;destructive&quot;,
and the dropped item is deleted from the canvas, otherwise it
reappears at the position where it was grabbed. If on the other hand
the cursor leaves the drop zone of <TT>i</TT> again without the grab
button being released, the function <TT>leave i</TT> is called, so <TT>i</TT>
can eg. revert its visual appearance to the normal state. <TT>leave i</TT>
is also called after a drop operation (no matter if destructive or
not), but it is <B>not</B> called if the preceding call of <TT>enter</TT>
returned <TT>false</TT>. 
</P>
<P>If the grab button is released with the grabbed item being over no
other item's drop zone, the item is moved to that place on the canvas
and the function <TT>release</TT> is called. <TT>release</TT> is also
called after a non-destructive drop operation for all the dropped
items. 
</P>
<P>The drag&amp;drop-package further interfaces to the clipboard to
allow interchange of objects across different drag&amp;drop canvases,
or to other applications. See the section on the clipboard below. 
</P>
<P>The file
<TT>toolkit/tests+examples/boxes.sml</TT> contains a simple example
of how to use the drag&amp;drop package.
</P>
<H3>4.12. The Generic Graphical User Interfaces <tt>GenGUI</tt> and <TT>TGenGUI</tt></H3>
<P>The module GenGUI implements a simple generic user interface based
on the drag&amp;drop paradigm. It comes in two variants: one based on
&quot;flat&quot; objects (GenGUI); and another in which the
objects are hierarchically organized as trees (TGenGUI). Both
versions of the component are based on the common infrastructure
(CI).</P>
<P>It has been implemented with a view to implementing user
interfaces for applications based on the theorem prover Isabelle, but
can also be used without Isabelle. On top of it, we have bilt a more
elaborate user interface, the generic user interface toolkit <TT>GenIT</TT>.
In <TT>GenIT</TT>, the construction history of objects is recorded,
and becomes a first-class object of the interface. This allows
features such as replay, redo, change and dependency management, and
history navigation all to be implemented on the generic level of the
GenGUI. Because of its size and complexity, we have decided to make
<TT>GenIT</TT> available separately from <B>sml_tk</B>. See also
[LW99,LW00]. 
</P>
<P>The application one wishes to build an interface for is described
by a signature <TT>SIMPLE_APPL_SIG</TT>. The generic user interface
is a functor 
</P>
<PRE STYLE="margin-bottom: 0.2in"> functor SimGenGui(appl: SIMPLE_APPL_SIG) : SIMGENGUI</PRE><P>
which when instantiated with an application returns a graphical user
interface for that application. 
</P>
<H3>4.12.1. Basic Visual Appearance</H3>
<P>Every application provides a collection of <I>objects</I>, which
the GenGUI displays in a window (the ``notepad''). Every object has a
<I>type</I>, which determines the icon used to represent the object
on the manipulation area, and the operations applicable to that
object. In TGenGUI, aside to the notepad, there is a navigation board
displaying the object hierarchy, where the folders correspond to
contents of the notepad and the leafs the objects of the system.
</P>
<P>Operations come in three variations: nullary operations,
corresponding to constants, or in other words, the objects which are
there from the start; unary operations, which take exactly one object
as their argument; and binary operations, which take two objects
arguments. 
</P>
<P>Unary operations are applied by clicking on the object with the
right mouse button, and selecting the corresponding operation from
the menu appearing. Binary operations are applied by grabbing an
object with the left mouse button, dragging it across the screen, and
dropping onto another object. 
</P>
<P>New objects can be created as results of unary or binary
operations. 
</P>
<H3>4.12.2. Modelling in <TT>SIMPLE_APPL_SIG</TT></H3>
<P>In the signature <TT>SIMPLE_APPL_SIG</TT>, there are two types
<TT>object</TT> and <TT>objtype</TT>, modelling the objects and the
possible object types respectively. The typing is modelling by a
function <TT>obj_type: object -&gt; objtype</TT>, assigning to each
object a type, and its extension <TT>objlist_type : object list -&gt;
objtype</TT> to lists of objects. 
</P>
<P>Further, objects may have a limited form of state, as modelled by
the type <TT>mode</TT>. The mode of an object is given by the
<TT>sel_mode : object-&gt; mode</TT> function, and set by the
<TT>set_mode : object* mode-&gt; function</TT>. The mode can be set
by the user with a pop-up menu provided by GenGUI; to implement this,
modes have to have a name (given by <TT>mode_name: mode-&gt; string</TT>),
and the range an object's modes can take is limited by its type
(<TT>modes: objtype-&gt; mode list</TT>). 
</P>
<P>The type <TT>new_object</TT> models objects which are about to
appear on the notepad. They are given by an object, a position where
it should appear, and a direction (indicated by <TT>TkTypes.AnchorKind</TT>)
where it should appear if there already is an object at the indicated
direction. (The <A HREF="#gengui_conf">configuration option</A> delta
determines the minimum distance of objects when placing new objects.)
Unary operations come in two flavours, <I>standard</I> operations and
ones depending on the type of the object. Standard operations are
available for all objects, and comprise of a list given by <TT>std_ops</TT>
(typically, the first of this list will be a function to display an
object), and two special operations <TT>rename</TT> and <TT>delete</TT>.
Rename is called with the object, and a continuation with which the
name of the object can be set. The actual querying the user for a
name, and more importantly accepting or rejecting the user's choice,
has to be implemented by the application. In contrast, <TT>delete</TT>
is called when the object is about to be deleted to allow the
application to clean up; the actual deletion (i.e. removal from the
notepad) is implemented by <TT>GenGUI</TT>. This is described by the
signature <TT>SIMPLE_APPL_SIG</TT>, of which we have this excerpt: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature SIMPLE_APPL_SIG =</FONT>
<FONT SIZE=3> sig</FONT>

<FONT SIZE=3> eqtype objtype</FONT>
<FONT SIZE=3> eqtype mode</FONT>

<FONT SIZE=3> type object</FONT>
<FONT SIZE=3> type new_object = object * TkTypes.Coord* TkTypes.AnchorKind</FONT>


<FONT SIZE=3> (* Typing objects *)</FONT>

<FONT SIZE=3> val obj_type : object -&gt; objtype</FONT>
<FONT SIZE=3> val objlist_type : object list -&gt; objtype Option.option</FONT>

<FONT SIZE=3> val is_constructed : objtype-&gt; bool</FONT>
<FONT SIZE=3> (* objects of this type are construction objects *)</FONT>

<FONT SIZE=3> (* Each object has a name, which can be selected and changed</FONT>
<FONT SIZE=3> * with the standard rename operation (below).</FONT>
<FONT SIZE=3> *)</FONT>
<FONT SIZE=3> val sel_name : object -&gt; string Option.option</FONT>

<FONT SIZE=3> (* Modes, and how to select, set and name them.</FONT>
<FONT SIZE=3> *)</FONT>
<FONT SIZE=3> val modes : objtype -&gt; mode list</FONT>
<FONT SIZE=3> val mode_name : mode -&gt; string</FONT>
<FONT SIZE=3> val sel_mode : object -&gt; mode</FONT>
<FONT SIZE=3> val set_mode : object* mode-&gt; unit</FONT>

<FONT SIZE=3> (* Icons. Crucially, changing the mode may change the icon. *)</FONT>
<FONT SIZE=3> val icon : objtype* mode -&gt; Icons.icon</FONT>

<FONT SIZE=3> (* constants *)</FONT>
<FONT SIZE=3> val init : unit -&gt; new_object list</FONT>

<FONT SIZE=3> (* standard unary operations *)</FONT>
<FONT SIZE=3> val std_ops : ((object -&gt; unit)* string) list</FONT>
<FONT SIZE=3> val rename : object -&gt; (string-&gt; unit)-&gt; unit</FONT>
<FONT SIZE=3> val delete : object -&gt; unit</FONT>

<FONT SIZE=3> (* object-type-specific unary operatons *)</FONT>
<FONT SIZE=3> val mon_ops : objtype -&gt;</FONT>
<FONT SIZE=3> ((object* TkTypes.Coord -&gt;</FONT>
<FONT SIZE=3> (new_object -&gt; unit) -&gt; unit) * string) list</FONT>

<FONT SIZE=3> (* binary operations *)</FONT>
<FONT SIZE=3> val bin_ops : objtype* objtype -&gt; (object* SmlTk.Coord*</FONT>
<FONT SIZE=3> object list*</FONT>
<FONT SIZE=3> (new_object-&gt; unit)-&gt; unit) Option.option</FONT></PRE><P>
The type of <TT>mon_ops</TT> and <TT>bin_ops</TT> certainly requires
an explanation. Both are indexed by the type of the object(s)
involved, which is the first argument. 
</P>
<P>For an object of type <TT>t</TT>, <TT>mon_ops t</TT> is a list of
pairs <TT>[(f_1,s_1), ..., (f_n, s_n)]</TT>, where <TT>s_i</TT> is
the name of the operations under which it appears in the menu, and
<TT>f_i:object -&gt; (object -&gt; unit) -&gt; unit</TT> is a
function implementing the operation, taking the object as its
argument, and a continuation (of functionality <TT>new_object-&gt;
unit</TT>) as its second argument, by which new objects can be
introduced to the notepad area (so each call of the continuation
results in the appearance of exactly one object and its subsequent
appearance on the notepad). 
</P>
<P>For two objects of type <TT>t_1</TT> and <TT>t_2</TT>
(corresponding to an object of type <TT>t_2</TT> being dropped onto
an object of type <TT>t_1</TT>), <TT>binOps t_1 t_2</TT> is an
option: either it is <TT>NONE</TT> which means that the drop
operation is not possible; or it is <TT>SOME f</TT> where <TT>f</TT>
is a function taking as its first argument the object being dropped
onto, as its second argument the singleton list of the object being
dropped, and as a third argument a continuation producing new objects
on the notepad. Both the dropping and the dropped object remain
unchanged (to implement operations changing objects, see below). If
<TT>binOps t_1 t_2</TT> is <TT>SOME f</TT>, its icon is highlighted
(see <A HREF="#icons">Section 4.4.4. below</A>) to indicate that the
operation is possible. 
</P>
<H3>4.12.3. Constructing Objects</H3>
<P>The only way to change an object's internal structure is the
<I>construction area</I>. The general idea here is that each
instantiation of the GenGUI should be thought of as an application to
build objects of one specific type. For example, in the
Transformation Application System TAS the main construction objects
are programs, and the other objects are program transformations,
parameter instantiations etc. (see [LW99]), and in the interface
IsaWin to the theorem prover Isabelle, the main construction objects
are proofs (for theorems), and the other objects are theorems,
theories, rewriting sets etc. 
</P>
<P>A construction object can be opened by double-clicking it with the
left mouse button. A (sub)-window will appear (see <A HREF="#gengui-conf">configuring
GenGUI below</A>) showing the ``internals'' of the object, possibly
along with menus, buttons and other widgets. One can now either use
these to change the objects' internal structure, or one can drag down
objects from the manipulation area to interact with the object under
construction. If one is done, there should be a closing button or
menu entry by which one can close the construction area again. The
specifics and visual appearance of the construction area are entirely
dependent on the application in question (hence there <I>should</I>
be a closing button, technically this is not enforced), and have to
be implemented by the application as follows. 
</P>
<P>Note also that there is no restriction to one type of object-
object types which can be constructed are those for which the
predicate <TT>is_constructed</TT> is true. The construction area is
described by the following excerpt from the signature <TT>APPL_SIG</TT>:
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> type ca</FONT>

<FONT SIZE=3> val area_ops : objtype-&gt; ca-&gt; object list-&gt; unit</FONT>

<FONT SIZE=3> val area_open : TkTypes.WinId* object* (object -&gt; unit) -&gt;</FONT>
<FONT SIZE=3> (ca* TkTypes.Widget list* (unit-&gt; unit))</FONT>
<FONT SIZE=3> val area_init : unit-&gt; unit</FONT></PRE><P>
The type <TT>ca</TT> models the state of the construction area. When
an object is opened in the construction area, <TT>area_open</TT> is
called with the object and the identifier of the window in which the
construction area sits. This may be GenGUI's window, or a separate
window, as determined by the configuration of GenGUI. The third
argument to <TT>area_open</TT> is a function which is called when the
construction is finished; it creates one (or more) objects on the
notepad, most notably the one which has been constructed. Be sure to
call this function with the constructed object prior to closing the
construction area, otherwise the object will disappear in a puff of
SML. <TT>area_open</TT> returns a triple, consisting of the state of
the construction area just created, a list of widgets making up the
construction area, and a function to be called after the widgets have
been installed which initializes them. 
</P>
<P>In contrast, <TT>area_init</TT> is just called once, after GenGUI
has been started, e.g. to initialize variables for radiobuttons. When
calling <TT>area_init</TT> the construction area is not open, so do
not try to initialize widgets here. 
</P>
<P>Finally, dragging an object down from the notepad into the
constructoin area results an operation being triggered. The operation
is given by <TT>area_ops: objtype-&gt; ca-&gt; object list-&gt; unit</TT>
which takes as argument the type of the object(s) dragged down, the
state of the constrution area, and the actual objects; it does not
have a meaningful return value. 
</P>
<P><A NAME="icons2"></A><A NAME="icons"></A>As we can see, the
construction area even more relies on side effects than the rest of
the GenGUI. The functional purist shudders, since this also means we
have to provide functionality like history navigation (or the close
button) individually, for each application, rather than on a generic
level. These failings area remedied in GenIt. <BR><BR><BR>
</P>
<H3>4.12.4. Configuring GenGUI</H3>
<P>Like the utility windows, the visual appearance of the GenGUI can
be configured. This configuration is handled by the substructure
<TT>structure Conf: GENGUI_CONF</TT> of the application with the
following signature. Apart from visual details like colours, window
sizes and icons, we can also configure wether icons should remain
visible while being dragged across the notepad (<TT>moveOpaque</TT>),
and wether the construction area should be a subwindow of the
notepad, or a separate window (<TT>oneWindow</TT>). 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace"><FONT SIZE=3>signature GENGUI_CONF =</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> sig</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> (* This is the width and height of the construction area *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val width : int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val height : int</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* The background colour of the construction area *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val background : TkTypes.Color</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* The font and the width of the box, in pixels,</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * used to display the icons *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val iconNameFont : TkTypes.Font</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val iconNameWidth : int</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* The icon used to display the trashcan, and its initial position *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val trashcanIcon : unit-&gt; Icons.icon</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val trashcanCoord : TkTypes.Coord</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* If opaqueMove is true, then the whole item will move if it</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * is grabbed; ows. only change cursor to indicate an object is</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * being moved. *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val moveOpaque : bool</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* If oneWindow is true, the construction area will appear as</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * a widget within the lower part of the window (which will be</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * large enough to hold it. Actually, this should be called _one</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * widget_, since it means that both construction and assembly</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * come within one frame); otherwise, the construction area</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * will appear as a separate window.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val oneWindow : bool</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* The height and width of the construction area, and the</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * position of the window. The X/Y position and the caTitle options</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * determine the placing and title of the construction area window,</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * and only take effect if oneWindow is false.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val caHeight : int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val caWidth : int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val caXY : (int* int) Option.option</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val caTitle : string-&gt; string</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* The minimum distance between two objects' dropzones when placing</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * new objects</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val delta : int</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> end</FONT></FONT></PRE><H3>
<FONT FACE="times, serif"><FONT SIZE=4>4.12.5. Export signature</FONT></FONT></H3>
<P><FONT SIZE=3><FONT FACE="times, serif">The export signature of
</FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">GenGUI</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
divides roughly into two parts. The first block describes single
objects and how to introduce them onto the notepad. The second part
models the state of </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">GenGUI</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
as a whole (type </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">gui_state</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">).
There is an initial state </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">initial_state</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
corresponding to no objects being created yet, a function
</FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">state:unit-&gt;
gui_state</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif">
which returns the current state of notepad and construction area, and
a function </FONT></FONT><TT><FONT SIZE=3><FONT FACE="times, serif">init:gui_state-&gt;
unit</FONT></FONT></TT><FONT SIZE=3><FONT FACE="times, serif"> which
has to be used as the initialization function of the main window,
because it initializes GenGUI. If GenGUI suddenly behaves very
strange indeed (e.g. doesn't react to drag&amp;drop) this is most
likely caused by failing to initialize it properly. Finally, the
whole generic interface is just a widget (isn't everything?): </FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in"><FONT FACE="courier, monospace"><FONT SIZE=3>signature GENGUI_SIG =</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> sig</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type object</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type new_object</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> val intro : new_object -&gt; unit</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> (* Introduce (not &quot;create&quot; really) a new object</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * onto the manipulation area. *)</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* the state of the gui *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> type gui_state = new_object list</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* The GenGUI main widget. You MUST use the init function below</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * to initialize this widget. (Note GenGUI doesn't check this</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * itself.) *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val main_wid : TkTypes.WinId -&gt; TkTypes.Widget</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* In the following, init takes a gui_state and returns a function</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * which has to be used as the init function of the main window,</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * as it sets up the GenGUI.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> *</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * state returns a gui_state suitable as an argument to init.</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> *)</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> val init : gui_state-&gt; unit</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> (* call that as init action of main window *)</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> val state : unit-&gt; gui_state</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* This is the initial state which only has those objects as given</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * by the application's init() function (see above). *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val initial_state : unit-&gt; gui_state</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> exception GenGUI of string</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> (* Something went wrong. If this exception is raised, something</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> * has badly, unrecoverably (for this session) gone wrong. *)</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> (* Resynchronize all icons, e.g. if objects have changed their mode. *)</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> val redisplay_icons : (object-&gt; bool)-&gt; unit</FONT></FONT>


<FONT FACE="courier, monospace"><FONT SIZE=3> type objectlist= object list</FONT></FONT>

<FONT FACE="courier, monospace"><FONT SIZE=3> structure CB : CLIPBOARD</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> sharing type CB.obj = objectlist</FONT></FONT>
<FONT FACE="courier, monospace"><FONT SIZE=3> end</FONT></FONT></PRE><H3>
4.12.6. An Example</H3>
<P>The file <TT>toolkit/tests+examples/simpleinst.sml</TT> contains a
small example of how to use the generic graphical user interface. 
</P>
<P><TT>simpleinst</TT> knows two object types, texts and numbers.
Texts can be concatenated by drag&amp;drop (the dropped text being
appended to the one it is dropped onto), or they can be opened and
edited in the construction area. Numbers, on the other hand, have
four modes, corresponding to the four basic arithmetical operations.
When dropping a number onto another, it is added to, subtracted from,
multiplied with, or it divides the number it is dropped onto,
corresponding to the mode of the dropped object. 
</P>
<P>There is a button <TT>importFile</TT> which calls the filer to
select a file the contents of which (as a text) then appear on the
manipulation area. The following picture shows the visual appearance
of <TT>simpleinst</TT> with the object obtained by dropping the
predefined object <TT>Jerusalem 2</TT> onto <TT>Jerusalem 1</TT>
currently open in the construction area: 
</P>
<P><IMG SRC="images/simpleinst.gif" NAME="Grafik10" ALT="[Simple Instantation]" ALIGN=BOTTOM WIDTH=700 HEIGHT=400 BORDER=0>
</P>
<P>The visual appearance of a system obtained by instantiating <TT>GenGUI</TT>
can be customised considerably. The basic layout will remain the
same, with the the construction area appearing in the bottom half of
the screen, but the construction area's appearance and functionality
are freely programmable. The main window of the simple instantiation
can have menus and/or buttons attached to it, and of course the
icons, including the trashcan icon, can be changed. 
</P>
<H3><BR><BR>
</H3>
<H3 STYLE="margin-top: 0in">4.13. Tabs</H3>
<P>An implementation of tabs as in the following screenshot (taken
from the tabs example in <FONT FACE="courier, monospace">src/toolkit/tests+examples/tabs_ex.sml</FONT>),
</P>
<P><IMG SRC="images/tabs.gif" NAME="Grafik13" ALIGN=BOTTOM WIDTH=600 HEIGHT=350 BORDER=0> 
</P>
<P><BR><BR>which has the following export signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature TABSSIG =</FONT>
<FONT SIZE=3> sig</FONT>
<FONT SIZE=3> exception Error of string</FONT>

<FONT SIZE=3> val tabs : {pages : {title : string,</FONT>
<FONT SIZE=3> widgets : SmlTk.Widgets,</FONT>
<FONT SIZE=3> show : SmlTk.SimpleAction,</FONT>
<FONT SIZE=3> hide : SmlTk.SimpleAction,</FONT>
<FONT SIZE=3> shortcut : int option} list,</FONT></PRE><P>
The definition of the displayed pages including the page title, the
widgets displayed within the frame building the page, and a shortcut
key as an integer value (the nth char in the page title). The show
and hide actions are needed to initialize the widgets when a page is
shown, and save its content when a page is hidden. Therefore the show
action is called when the widgets are allready displayed, and the
hide action is called just before the widgets are (temporarily)
destroyed. There is also an example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/tabs_ex.sml</FONT>).
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>configure : {width : int,</FONT>
<FONT SIZE=3> spare : int,</FONT>
<FONT SIZE=3> height : int,</FONT>
<FONT SIZE=3> font : SmlTk.Font,</FONT>
<FONT SIZE=3> labelheight : int}}</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">These are the available
configuration options: The width and height of the frame containing
the widgets of a single page, the amount of pixels to spare right
from the page titles, the font of the page titles and the maximum
height of the labels containing the page titles (height of the
specified font + x).</FONT></FONT> 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>-&gt; SmlTk.Widget *</FONT>
<FONT SIZE=3> SmlTk.Binding list</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The returned canvas widget in
which the tabs are displayed and the binding list containing the key
shortcuts, which should be bound to the window containing the tabs.
Unfortunately there is no other way of key adding bindings to the
tabs, because Tcl/Tk does not support key bindings to canvases.</FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>val std_conf : {width : int,</FONT>
<FONT SIZE=3> spare : int,</FONT>
<FONT SIZE=3> height : int,</FONT>
<FONT SIZE=3> font : SmlTk.Font,</FONT>
<FONT SIZE=3> labelheight : int}</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">This is a standard
configuration to use with the tabs (comments on parameters, see
above).</FONT></FONT> 
</P>
<H3 STYLE="margin-top: 0in">4.14. Tables</H3>
<P>A simple implementation of tables, that returns a grid of labels
within a frame (screenshot taken from the tables example in
<FONT FACE="courier, monospace">src/toolkit/tests+examples/table_ex.sml</FONT>):
</P>
<P><IMG SRC="images/tables.gif" NAME="Grafik11" ALIGN=BOTTOM WIDTH=600 HEIGHT=250 BORDER=0> 
</P>
<P>The structure <FONT FACE="courier, monospace">Table</FONT> has the
following export signature: 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3>signature TABLE_SIG =</FONT>
<FONT SIZE=3> sig</FONT>
<FONT SIZE=3> val table : {constant_column_width : bool,</FONT></PRE><P>
If set to <FONT FACE="courier, monospace">true</FONT>, the largest
column width found is applied to all columns. 
</P>
<PRE STYLE="margin-left: 0.79in"> <FONT SIZE=3>headline_relief : SmlTk.RelKind,</FONT>
<FONT SIZE=3> headline_borderwidth : int,</FONT>
<FONT SIZE=3> headline_foreground : SmlTk.Color,</FONT>
<FONT SIZE=3> headline_background : SmlTk.Color,</FONT>
<FONT SIZE=3> field_relief : SmlTk.RelKind,</FONT>
<FONT SIZE=3> field_borderwidth : int,</FONT>
<FONT SIZE=3> field_foreground : SmlTk.Color,</FONT>
<FONT SIZE=3> field_background : SmlTk.Color,</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The relief, borderwidth,
foreground and background colour of the headline and table fields.</FONT></FONT>
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>container_background : SmlTk.Color} -&gt;</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The background colour of the
frame containing the table fields (visible if a different borderwidth
is set for headline and table fields).</FONT></FONT> 
</P>
<PRE STYLE="margin-left: 0.79in; margin-bottom: 0.2in"> <FONT SIZE=3>SmlTk.AnnoText list list -&gt; SmlTk.Widget</FONT></PRE><P>
The textual content of the table. Adding widgets to the annotated
text might confuse the calculation of a constant comlumn width. 
</P>
<PRE STYLE="margin-bottom: 0.2in"></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">The returned frame widget
containing the table.</FONT></FONT> 
</P>
<PRE STYLE="margin-left: 0.79in"><FONT SIZE=3> val std_conf : {constant_column_width : bool,</FONT>
<FONT SIZE=3> headline_relief : SmlTk.RelKind,</FONT>
<FONT SIZE=3> headline_borderwidth : int,</FONT>
<FONT SIZE=3> headline_foreground : SmlTk.Color,</FONT>
<FONT SIZE=3> headline_background : SmlTk.Color,</FONT>
<FONT SIZE=3> field_relief : SmlTk.RelKind,</FONT>
<FONT SIZE=3> field_borderwidth : int,</FONT>
<FONT SIZE=3> field_foreground : SmlTk.Color,</FONT>
<FONT SIZE=3> field_background : SmlTk.Color,</FONT>
<FONT SIZE=3> container_background : SmlTk.Color}</FONT></PRE><P>
<FONT SIZE=3><FONT FACE="times, serif">A standard configuration
offering standard values for the parameters described above.</FONT></FONT>
</P>
<H2><A NAME="installation"></A>5. Installation</H2>
<P>This section details the software and hardware requirements
necessary to run <B>sml_tk</B>, the installation procedure, the
runtime configuration of <B>sml_tk</B> and other helpful hints. 
</P>
<H3>5.1. Software and Hardware Requirements</H3>
<P><B>sml_tk</B> requires the following software: 
</P>

For the default configuration (pipe-based communcation with Tcl/Tk), a
Standard ML compiler implementing the <TT><A
HREF="http://www.cs.bell-labs.com/~jhr/sml/basis/pages/posix-chapter.html"><U><FONT
COLOR="#0000ff">Posix</FONT></U></A></TT> and <TT><A
HREF="http://www.cs.bell-labs.com/~jhr/sml/basis/pages/unix.html"><U><FONT
COLOR="#0000ff">Unix</FONT></U></A></TT> structures from the <A
HREF="http://www.cs.bell-labs.com/~jhr/sml/basis/">SML Basis
Library</A>. In particular, <b>sml_tk</b> is known to work with the following
compilers:
<ul><li><A
HREF="http://cm.bell-labs.com/cm/cs/what/smlnj/index.html">Standard ML
of New Jersey (SML/NJ)</a>, version 110.0.6 and 110.0.7;
    <li><A HREF="http://www.lfcs.informatics.ed.ac.uk/software/polyml/">PolyML</A>, version 4.0beta1;
    <li><A HREF="http://www.dina.dk/~sestoft/mosml.html">MoscowML</A>, version 2.00.
</ul></P>

<p>A <tt>wish</tt> (Tcl/Tk interpreter) of version 4.0 to 8.0 or
later. If you do not know if the wish is installed on your system,
type <TT>wish</TT> in a shell window; you should get a Tcl prompt
(<TT>%</TT>) and a blank window called <TT>wish</TT>.  Otherwise,
download Tcl/Tk from <A
HREF="http://dev.scriptics.com/software/tcltk">here</A>.</p>

<P>Optionally, a standard make for installation (GNU make and Solaris
make are known to work).</P>
		
<p>The <I>TCL_INSIDE</I> configuration only runs with <A
HREF="http://cm.bell-labs.com/cm/cs/what/smlnj/index.html">Standard 
ML of New Jersey</A> (SML/NJ), but should be easier to port to 
non-Posix systems such as Windows. </p>

<P>Optionally, a standard make for installation (GNU make and Solaris
make are known to work).</P>

<P><B>sml_tk</B> has no particular hardware requirements, and is
known to run on the Solaris and Linux operating systems.
</P>
<H3>5.2. Obtaining and Installing <B>sml_tk</B></H3>
<P><B>sml_tk</B> can be obtained as a single <TT>tar</TT> file from
the <A HREF="http://www.informatik.uni-bremen.de/~cxl/sml_tk/home.html"><B><U><FONT COLOR="#0000ff">sml_tk</FONT></U></B>
home page</A>
</P>
<H4>Configuring <B>sml_tk</B></H4>
<P>Before you start the installation itself, you have to configure
<B>sml_tk</B> to your system's need by setting the variables in the
first section of the Makefile to appropriate values. The most
critical of these are obviously <TT>SMLTK_LIB</TT> and <TT>SMLTK_TCL</TT>:
</P>
<DL>
        <DT><TT>SMLTK_TCL</TT> 
	</DT><DD>
	the full pathname of the Tcl/Tk shell <tt>wish</tt>. 
	</DD><DT>
	<TT>SMLTK_LIB</TT> 
	</DT><DD>
	the full pathname of the runtime library of <B>sml_tk</B>, which
	contains files such as images and icons needed at runtime. The
	default is the directory lib in the <B>sml_tk</B> toplevel
	directory. 
	</DD><DT>
	<TT>SMLTK_LOGFILE</TT> 
	</DT><DD>
	the full pathname of the <I>logfile</I>. The logfile is a protocol
	file useful in debugging <B>sml_tk</B> applications (see <A HREF="manual.html#appx">the
	appendix of the <B>sml_tk</B> manual</A>). If it is not set, no
	protocol is written; this is the default. 
	</DD><DT>
	<TT>SMLTK_BINARY</TT> 
	</DT><DD>
	the full pathname of the binary to be produced. The directory has to
	exists and be writeable. (The default Makefile does not
        produce binaries with MoscowML.)
	</DD><DT>
	<TT>COMP</TT> 
	</DT><DD>
	the name of the compiler: can be <tt>njml</tt>, <tt>poly</tt>
        or <tt>mosml</tt>. 
        </DD><DT>
	<TT>COMP_BIN</TT> 
        </DT><DD>
	the name of the compiler, as a shell command or full pathname of its
	binary. For using the PolyML-compiler, you will have to add the path 
        to the ML-base file (Please save this file yourself after a build; 
        this is not handled by the Makefile!).
        </DD><DT>
	<TT>COMP_NAME</TT> 
	</DT><DD>
	the name of the compiler as a string, which will apear in the banner
	of the produced binary (<TT>sml_tk for ...</TT>). 
	</DD></DL>
<P>
The variables <TT>SMLTK_LIB</TT>, <TT>SMLTK_LOGFILE</TT> and
<TT>SMLTK_TCL</TT> also control the runtime of <B>sml_tk</B> (see <A
HREF="#config-runtime">section 5 of the <B>sml_tk</B> manual</A>).
<B>sml_tk</B> can be installed by producing a dumped image, or by
using SML/NJ's compilation manager. The installation itself is
painless.  Just type <TT>make</TT> in the toplevel directory, and it
will produce an image; alternatively, use SML/NJ's compilation
manager (see below).
</P>
<P>To remove the Compilation Manager's temporary files, do <TT>make
clean</TT>. To also remove the dumped image, use <TT>make realclean</TT>.
</P>
<H4>The Configuration <I>TCL_INSIDE</I></H4>
<P><A NAME="config-runtime"></A>As already mentioned previously,
<B>sml_tk</B> comes in two different configurations: the default one,
based on a loose coupling with the Tcl/Tk shell, and another one
called&nbsp;<SPAN STYLE="font-weight: medium"><I>TCL_INSIDE</I><SPAN STYLE="font-style: normal">,
based on linking the Tk-sources on the C-level to the NJML-runtime
system. To install the configuration&nbsp;</SPAN><I>TCL_INSIDE&nbsp;</I><SPAN STYLE="font-style: normal">is
the package <B>njml_patch</B>which can be downloaded from the <B>sml_tk</B>
web site is needed. It has to be applied to an existing SML/NJ
installation which it transforms by adding additional sources and
patching others at the level of C source files. After succesfully
running the&nbsp;</SPAN><I>Makefile</I><SPAN STYLE="font-style: normal">in
<B>njml_patch</B></SPAN> (for which various system dependent paths
have to be set appropriately; see documentation for details), the
compilation of&nbsp;<B><SPAN STYLE="font-style: normal">sml_tk</SPAN></B>
on top of this extended runtime system is performed with the flag
TCL_INSIDE set on. The effect is limited only to a very small portion
of <B>sml_tk</B>.</SPAN> 
</P>
<H3>5.3 <B>sml_tk</B> Runtime Configuration</H3>
<P>The following variables govern the runtime behaviour of <B>sml_tk</B>:
</P>
<UL>
	<LI><TT>SMLTK_LIB</TT> is the full
	pathname of the runtime library of <B>sml_tk</B>. In a compiled
	<B>sml_tk</B> application, you only need this directory, which
	contains image files and the odd shellscript. Of course, you may
	want to add image files for your own applications here as well.</LI>
	<LI><TT>SMLTK_LOGFILE</TT> is where the
	<I>logfile</I> can be found. The logfile is a protocol of the
	communication between <B>sml_tk</B> and the wish. It can be useful
	for the experienced user in debugging <B>sml_tk</B> applications
	(see the <A HREF="#appx">appendix</A>);</LI>
	<LI><TT>SMLTK_TCL</TT> is the complete path to the Tcl/Tk wish.</LI>
</UL>
<P>These are given default values in the <TT>Makefile</TT>. The
default values can be overridden by setting an environment variable
of the same name, and calling the function <TT>SmlTk.init();</TT>
only the options to which the corresponding environment variable
actually exists are changed, allowing a selective update. The
environment variable can in turn be overriden by a commandline
argument of the form <TT>--&lt;VARNAME&gt;=value</TT> (as in
<TT>--SMLTK_TCL=/bin/wish</TT>) when calling an <B>sml_tk</B>
application from the shell. Finally, their value can be changed from
within SML by calling e.g. <TT>SmlTk.updTclPath</TT>, see <A HREF="#init-config">Sect.
3.2.17</A> above. 
</P>
<H3><A NAME="extensions"></A>5.4. Porting, Helpful Household Tips and
Known Problems</H3> <H4>Porting <B>sml_tk</B></H4> <P><B>sml_tk</B>
has been developed with SML/NJ, version 110.  Meanwhile, other SML97
compilers have become available, and <b>sml_tk</b> runs under PolyML
and MoscowML as well (apart from small details such as the
kill-mechanism and the generation of a binary image for MoscowML).
Given these experiences, we believe it should be relatively easy to
port <B>sml_tk</B> to other platforms and compilers; an experienced ML
programmer should be able to do this himself. The main work in porting
<B>sml_tk</B> to another compiler is to write a structure
<TT>SysDep</TT>, which implements the signature <TT>SYS_DEP</TT> (in
<TT>src/sys_dep.sig</TT>). The files <TT>njml.sml</TT>,
<TT>poly.sml</TT> and <TT>mosml.sml</TT> may serve as a starting
point.
</P>
<P>If you do port <B>sml_tk</B> to another operating system or SML
compilers, please let us know so we can support your port in future
releases of <B>sml_tk</B>. 
</P>
<P>We also invite further contributions to the toolkit library. If
you have written a piece of <B>sml_tk</B> software which is
sufficiently versatile to be of general use, then please do get in
touch with us. We would very much like to extend the toolkit library
in future releases. 
</P>
<H4>Tips&amp;Tricks </H4>
<P>This section contains some tips which you may find useful. 
</P>
<UL>
        <LI><p>If you don't want to produce a binary image, or are using
        Moscow ML, you can load <b>sml_tk</b> by <tt>use</tt>ing the
        file <tt>root_poly.sml</tt> and <tt>root_mosml.sml</tt> (for
        PolyML and Moscow ML respectively.)</p>

	<LI><P STYLE="margin-bottom: 0in">SML/NJ users can make
	efficient use of the Compilation Manager by including a
	reference to <TT>sml_tk/src/sources.cm</TT> in the entity
	description files of their application(s), and the CM will
	automatically compile <B>sml_tk</B> when needed. You may want
	to stabilize <B>sml_tk</B> in that case (see the manual for
	CM).
	</P>

	<LI><P STYLE="margin-bottom: 0in">The dumped images contain some of
	the examples found in the source distribution. If you do not want
	them, change this in <TT>src/sources.cm</TT>. 
	</P>
	<LI><P>The export interface of <B>sml_tk</B> consists of two
	structures <TT>TkTypes</TT> and <TT>SmlTk</TT>. If you want them to
	be opened in the dumped images, this can be changed in <TT>src/Makefile</TT>.
	Also, the dumped images call <TT>SmlTk.initSmlTk</TT> first thing
	they are loaded (in order to correctly set <TT>SMLTK_ROOT</TT> etc.
	from the environment variables). This can be changed in
	<TT>src/njml1.sml</TT> in the function <TT>xSmlTk</TT>. 
	</P>
</UL>
<H4>Known Problems</H4>
<UL>
	<P STYLE="margin-bottom: 0in">TCL_INSIDE is quite tricky to install.
	It requires the installation of the package &quot;njml_patch&quot;,
	that attempts to modify and extend the C-sources of the njml-runtime
	system and to link the Tk-library to it. This process highly depends
	on very machine-dependent features and may fail for various reasons.</P>
	<P><B>sml_tk</B> cannot send an interrupt to a running application
	(see the discussion in section 2), so one cannot implement an
	interrupt button. Interupts have to be sent to the window of the
	SML-shell.</P>
        <p>The interrupt mechanism doesn't work with SML compilers
        other than SML/NJ.</P>
</UL>
<H2>6. Bibliography</H2>
<P>[Fos 97] E. Foster-Johnson: Graphical Applications with Tcl and Tk
. M&amp;T Books . 2nd Edition December 1997 . ISBN:1558515690.
</P>
<P>[FW94] M. Fr&ouml;hlich, M. Werner: The Interactive
Graph-Visualization System daVinci - a User Interface for
Applications. Informatik-Bericht Nr. 5/94, Universit&auml;t Bremen,
1994. 
</P>
<P>[HM 97] M. Harrison, M. McLennan: Effective Tcl/Tk Programming.
Addison-Wesley, December 1997. ISBN: 0201634740. 
</P>
<P>[KSW96] Kolyang, T. Santen, B. Wolff: Correct and User-friendly
Implementations of Transformation Systems. In: M.C. Gaudel, J.
Woodcock (ed): FME'96: Industrial benefits and Advances of Formal
Methods, pp. 629-648. LNCS 1051,1996. 
</P>
<P>[Lib 94] D. Libes: Exploring Expect. O'Reilly 1994. ISBN:
1565920902.
</P>
<P>[LW99] C. L&uuml;th, B. Wolff: Functional Design and
Implementation of Graphical User Interfaces for Theorem Provers.
Journal of Functional 9(2), 167-- 189, 1999. 
</P>
<P>[LW00] C. L&uuml;th, B. Wolff: TAS - A Generic Window Inference
System. 13th International Conference on Theorem Proving in
Higher-Order Logics TPHOLs 2000, LNCS 1869, Springer Verlag. pages
405--422 
</P>
<P>[Oust 94],J. K. Ousterhout: Tcl and the Tk .Addison-Wesley . May
1994. ISBN: 020163337X. 
</P>
<P>[Pau 96] L. C. Paulsen: ML for the Working Programmer(2<SUP>nd</SUP>.
Ed.). Cambridge University Press 1996. See also
<A HREF="http://www.cl.cam.ac.uk/users/lcp/MLbook/">http://www.cl.cam.ac.uk/users/lcp/MLbook/</A>.
</P>
<P>[PR95] F. Pessaux, F. Rouaix: The Caml/Tk interface, Projet
Cristal, INRIA Roquencourt, July 1995.
<A HREF="ftp://ftp.inria.fr/lang/../INRIA/Projects/cristal/caml-light/camltk.dvi.tar.gz">ftp://ftp.inria.fr/lang/../INRIA/Projects/cristal/caml-light/camltk.dvi.tar.gz</A>.
</P>
<P>[REF 96] Tcl and Tk Reference Manual. Linux Systems Labs . May
1996. . See also <A HREF="http://www.tclconsortium.org/books/index.vet">http://www.tclconsortium.org/books/index.vet</A>.
</P>
<P>[VTS95] T. Vullinghs, D. Tuijnman, W. Schulte: &quot;Lightweight
GUIs for Functional Programming&quot;. PLILP 95, Utrecht, The
Netherlands, Sept. 20-22, 1995. 
</P>
<P>[Wel 97] B. Welch: Practical Programming in Tcl and Tk.
Prentice-Hall/PTR. 2nd Edition July 1997. ISBN: 0136168302. See also
http://www.tclconsortium.org/books/index.vet. <BR>&nbsp; <BR>&nbsp; 
</P>
<H2><A NAME="appx"></A>7. Appendix: A Commented Logfile</H2>
<P><B>sml_tk</B> can produce a <I>logfile</I> (see above) in which
the communication between SML and the wish is recorded. Logfiles can
be helpful in debugging applications, since they show what &quot;really&quot;
happened; in particular, this can show whether source of unexpected
behaviour lies in the SML code, or quirks of Tk (or, God forbid, a
bug in <B>sml_tk</B>). 
</P>
<P>Nevertheless, it should be stressed that logfiles are not for the
beginner, but rather the advanced user exploring the more intricate
features of both <B>sml_tk</B> and Tk. 
</P>
<P>In this appendix, we present a commented logfile produced by the
small example from section 1. The user interaction proceeds as
follows: after starting the program, enter a name in the text entry,
press return and close the window by clicking the quit box. Here is
the resulting logfile. 
</P>
<P>The general format of the logfile is that lines beginning with <TT>==</TT>
are sent from <B>sml_tk</B> to the wish, and lines beginning with <TT>&lt;==</TT>
are sent from the wish to <B>sml_tk</B>. It always starts with a
standard prelude, which sets up the wish for use with <B>sml_tk</B>: 
</P>
<PRE>== set tcl_prompt1 &quot;puts -nonewline {} &quot;
 set tcl_prompt2 &quot;puts -nonewline {} &quot;
proc Write {msg} {
 puts stdout $msg
 flush stdout
}
proc WriteSec {tag msg} {
 set status [catch {eval $msg} res]
 if {$status == 0} {
 puts stdout &quot;$tag $res&quot;
 } else {
 puts stdout &quot;ERROR $res&quot;
 }
 flush stdout
}
proc WriteCmd {tag msg} {
 set status [catch {eval $msg} res]
 if {$status == 0} {
 puts stdout &quot;$tag&quot;
 } else {
 puts stdout &quot;ERROR $res&quot;
 }
 flush stdout
}
proc WriteM {msg} {
 puts stdout $msg
 flush stdout
 puts &quot;EOM&quot;
 flush stdout
}</PRE><P>
Now follow the packing commands for the main window. Note the names:
the main window's Tk name will always be <TT>.</TT> (dot).
Sub-windows or widgets within a window, or subwidgets will always
have the name of the father window/widget, followed by a dot and
their own name. The names <TT>anowidXX</TT> are the anonymous widget
identifiers created by <TT>newWidgetId</TT>. 
</P>
<P>Here, the packing proceeds in the following order: first the frame
with its two components is packed, the text label &quot;name&quot; on
the left, and the text entry on the right followed by the bindings
for the text entry: 
</P>
<PRE>== WriteCmd &quot;CMDOK&quot; {pack [frame .anowid24 ] -side top}
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {pack [label .anowid24.anowid22 -text &quot;name:&quot;] -side left}
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {pack [entry .anowid24.anowid21 -width 20] }
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {bind .anowid24.anowid21 &lt;Return&gt; {Write &quot;WBinding main .anowid24.anowid21 &lt;Return&gt; (%b,%s,%x,%y,%X,%Y) &quot;}}
&lt;== CMDOK</PRE><P>
Note how the wish acknowledges execution of each command sent with
<TT>CMDOK</TT>. Further, one cannot see from the logfile what
<TT>&lt;Return&gt;</TT> has been bound to, since <B>sml_tk</B> only
binds it to a function indicating the event has occurred, and does
the mapping to the relevant ML function internally. The packing
continues with the quit button, and finishes with setting the window
title: 
</P>
<PRE>== WriteCmd &quot;CMDOK&quot; {pack [button .anowid23 -text &quot;Quit&quot; -command {Write &quot;Command main .anowid23&quot;}] -side bottom}
&lt;== CMDOK
== WriteCmd &quot;CMDOK&quot; {wm title . &quot;Please enter name&quot;}
&lt;== CMDOK</PRE><P>
Now <B>sml_tk</B> is waiting for user input. Hence, the next
communication is initiated by the wish, indicating that the <TT>&lt;Return&gt;</TT>
key has been pressed: 
</P>
<PRE STYLE="margin-bottom: 0.2in">&lt;== WBinding main .anowid24.anowid21 &lt;Return&gt; (96,0,80,16,277,193)</PRE><P>
On the ML side, the function <TT>endInput</TT> is executed. This
calls the <B>sml_tk</B> function <TT>readTextAll</TT> to read the
contents of the text widget. A value is requested from the wish with
<TT>WriteSec</TT>, and sent in a line preceded with <TT>VValue</TT>: 
</P>
<PRE>== WriteSec &quot;VValue&quot; {.anowid24.anowid21 get}
&lt;== VValue William Lee</PRE><P>
Then, the title of the window is set accordingly: 
</P>
<PRE>== WriteCmd &quot;CMDOK&quot; {wm title . &quot;William Lee&quot;}
&lt;== CMDOK</PRE><P>
Again, the system is waiting for something to happen. In this case,
the quit button (widget id <TT>anowid23</TT> is pressed. <B>sml_tk</B>
calls the function <TT>quit</TT>, which in turn closes the window: 
</P>
<PRE>&lt;== Command main .anowid23
== destroy .</PRE><P>
It should be pointed out that in an application of decent size, the
interaction between wish and <B>sml_tk</B> is not always as orderly
as above. In particular, bindings may be activated at any point, even
when <B>sml_tk</B> is waiting for a value from the wish. 
</P>
</BODY>
</HTML>
